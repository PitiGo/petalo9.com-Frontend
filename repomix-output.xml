This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  index.html
  manifest.json
  robots.txt
src/
  components/
    juegos/
      CarViewer.js
      Cube.js
      EnhancedCubes.js
      futbol_1.js
      GuessTheCountry.css
      GuessTheCountry.js
      HandInvadersGame.css
      HandInvadersGame.js
      handInvadersLogic.js
      ModelViewer.js
      Pass.js
      PixelatePass.js
      PongGame.js
      RenderPixelatedPass.js
      Runner3D.jsx
      SnakeGame.css
      SnakeGame.js
      SnakeGame3D.js
      SuperMarcos.css
      SuperMarcos.js
      Terminal.js
      ThreeJSCSS3DSprites.js
    shaders/
      ParticleSystem.js
      TorusKnot.js
    About.js
    Blog.js
    BlogPost.js
    Chat.js
    Contact.js
    CursorFollower.js
    EditPost.js
    ErrorComponent.js
    Footer.js
    GamePage.css
    GamePage.js
    GamePlayer.js
    GameRegistry.js
    Header.js
    Home.js
    Login.js
    ProtectedRoute.js
    SideBarMenu.js
    TextEditor.js
  css/
    about.css
    blog-new.css
    blogpost.css
    contact.css
    editor.css
    GamePage.css
    header.css
    home.css
    sidemenu.css
  App.css
  App.js
  index.js
.gitignore
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/juegos/GuessTheCountry.css">
/* Estilos específicos para el juego, encapsulados en un contenedor principal */
.guess-the-country-container {
    margin: 0 auto;
    padding: 20px;
    max-width: 1200px;
    background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #2d3748 100%);
    font-family: "Inter", "Segoe UI", "Arial", sans-serif;
    color: #e2e8f0;
    border-radius: 12px;
}

.guess-the-country-container h1 {
    text-align: center;
    margin-bottom: 30px;
    font-size: 2.2em;
    font-weight: 800;
    background: linear-gradient(135deg, #60a5fa 0%, #a855f7 50%, #f59e0b 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.guess-the-country-container .game-ui {
    display: flex;
    justify-content: space-around;
    align-items: center;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 20px;
    padding: 15px 25px;
    margin-bottom: 25px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.15);
}

.guess-the-country-container .game-stat {
    text-align: center;
}

.guess-the-country-container .game-stat-label {
    font-size: 0.9em;
    color: #cbd5e1;
    margin-bottom: 5px;
    text-transform: uppercase;
}

.guess-the-country-container .game-stat-value {
    font-size: 2em;
    font-weight: 700;
    color: #f8fafc;
    line-height: 1;
}

.guess-the-country-container .btn {
    padding: 12px 24px;
    border: none;
    border-radius: 16px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s;
    color: white;
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3);
}

.guess-the-country-container .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
}

.guess-the-country-container .map-container {
    background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
    border-radius: 24px;
    overflow: hidden;
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
    position: relative;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 25px;
}

.guess-the-country-container .country {
    cursor: pointer;
    stroke: rgba(255, 255, 255, 0.3);
    stroke-width: 0.8;
    transition: fill 0.3s ease;
}

.guess-the-country-container .country:hover {
    stroke: #fbbf24;
    stroke-width: 2.5;
    filter: brightness(1.15);
}

.guess-the-country-container .country-correct {
    fill: #2ecc71 !important;
}

.guess-the-country-container .country-incorrect {
    fill: #e74c3c !important;
}

.guess-the-country-container .info-panel {
    padding: 25px;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 24px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(20px);
}

.guess-the-country-container .info-panel h3 {
    margin: 0 0 15px 0;
    font-size: 1.8em;
    font-weight: 700;
    color: #f8fafc;
}

.guess-the-country-container .info-panel p {
    margin: 10px 0;
    font-size: 1.1em;
    line-height: 1.6;
    color: #cbd5e1;
}

.guess-the-country-container .info-panel strong {
    color: #e2e8f0;
}

.guess-the-country-container .loading {
    text-align: center;
    padding: 80px 20px;
    font-size: 1.5em;
}

.guess-the-country-container #worldMap {
    width: 100%;
    height: auto;
}

.guess-the-country-container .tooltip {
    position: absolute;
    background: rgba(15, 20, 25, 0.95);
    color: #e2e8f0;
    padding: 10px 14px;
    border-radius: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    font-size: 14px;
    z-index: 1000;
}
</file>

<file path="src/components/juegos/GuessTheCountry.js">
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import * as topojson from 'topojson-client';
import './GuessTheCountry.css';

const GuessTheCountry = () => {
    // Refs para acceder a los elementos del DOM de forma segura en React
    const svgRef = useRef(null);
    const tooltipRef = useRef(null);
    const infoPanelRef = useRef(null);
    const scoreRef = useRef(null);
    const remainingRef = useRef(null);
    const gameLogicRef = useRef({}); // Para almacenar variables del juego

    useEffect(() => {
        // --- DATA DEL JUEGO ---
        const TOP_15_COUNTRIES = [
            "India", "China", "United States of America", "Indonesia", "Pakistan",
            "Nigeria", "Brazil", "Bangladesh", "Russia", "Mexico",
            "Japan", "Ethiopia", "Philippines", "Egypt", "Vietnam"
        ];

        const populationData = {
            "India": 1428627663, "China": 1425671352, "United States of America": 339996563,
            "Indonesia": 277534122, "Pakistan": 240485658, "Nigeria": 223804632,
            "Brazil": 216422446, "Bangladesh": 172954319, "Russia": 144444359,
            "Mexico": 128455567, "Japan": 123294513, "Ethiopia": 126527060,
            "Philippines": 117337368, "Egypt": 112716598, "Vietnam": 98858950,
            "Germany": 83294633, "United Kingdom": 67736802, "France": 64756584,
            "Canada": 38781291, "Argentina": 45773884, "Australia": 26439111,
        };

        // --- VARIABLES DEL JUEGO Y MAPA ---
        const logic = gameLogicRef.current;
        logic.score = 0;
        logic.foundCountries = new Set();
        logic.gameOver = false;
        const NEUTRAL_COLOR = "#6b7280";

        let svg, g, path, countries, tooltip;
        const loadingDiv = document.getElementById('loading-game');

        async function initMap() {
            try {
                const world = await fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(response => response.json());
                if (loadingDiv) loadingDiv.style.display = "none";

                svg = d3.select(svgRef.current);
                const width = svgRef.current.clientWidth;
                const height = width * 0.5; // Aspect ratio 2:1
                svg.attr("viewBox", `0 0 1200 600`);

                const projection = d3.geoNaturalEarth1().scale(180).translate([1200 / 2, 600 / 2]);
                path = d3.geoPath().projection(projection);

                g = svg.append("g");
                countries = g.selectAll(".country")
                    .data(topojson.feature(world, world.objects.countries).features)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("d", path)
                    .on("click", handleCountryClick)
                    .on("mouseover", handleMouseOver)
                    .on("mouseout", handleMouseOut);

                tooltip = d3.select(tooltipRef.current);
                startGame();

            } catch (error) {
                console.error("Error loading map data:", error);
                if (loadingDiv) loadingDiv.textContent = "⚠️ Error loading map data.";
            }
        }

        function startGame() {
            logic.score = 0;
            logic.foundCountries.clear();
            logic.gameOver = false;

            countries.attr("fill", NEUTRAL_COLOR)
                .classed("country-correct", false)
                .classed("country-incorrect", false);

            updateUI();
            if (infoPanelRef.current) {
                infoPanelRef.current.innerHTML = `
                    <h3>📜 Instructions</h3>
                    <p>Click on the map to guess the world's <strong>15 most populous countries</strong>.</p>
                    <p>A correct guess will turn the country <strong>green</strong>. An incorrect guess will turn it <strong>red</strong>. Good luck!</p>
                `;
            }
        }

        function handleCountryClick(event, d) {
            if (logic.gameOver) return;

            const countryElement = d3.select(this);
            const countryName = d.properties.name;

            if (countryElement.classed("country-correct") || countryElement.classed("country-incorrect")) {
                return;
            }

            const isCorrect = TOP_15_COUNTRIES.includes(countryName);

            if (isCorrect) {
                if (!logic.foundCountries.has(countryName)) {
                    logic.score++;
                    logic.foundCountries.add(countryName);
                    countryElement.classed("country-correct", true);
                    updateInfoPanel(countryName, true);

                    if (logic.foundCountries.size === TOP_15_COUNTRIES.length) {
                        endGame();
                    }
                }
            } else {
                countryElement.classed("country-incorrect", true);
                updateInfoPanel(countryName, false);
            }

            updateUI();
        }

        function endGame() {
            logic.gameOver = true;
            if (infoPanelRef.current) {
                infoPanelRef.current.innerHTML = `
                    <h3>🏆 Congratulations! 🏆</h3>
                    <p>You've found all 15 most populous countries! Your final score is <strong>${logic.score}</strong>.</p>
                    <p>Press the restart button to play again.</p>
                `;
            }
        }

        function updateUI() {
            if (scoreRef.current) scoreRef.current.textContent = logic.score;
            if (remainingRef.current) remainingRef.current.textContent = TOP_15_COUNTRIES.length - logic.foundCountries.size;
        }

        function updateInfoPanel(countryName, isCorrect) {
            const population = populationData[countryName] || "Not Available";
            const formattedPopulation = typeof population === 'number'
                ? population.toLocaleString('en-US')
                : population;

            const title = isCorrect ? `<h3>Correct! ✅ ${countryName}</h3>` : `<h3>Incorrect ❌ ${countryName}</h3>`;
            const message = isCorrect
                ? `<p>Excellent! ${countryName} is one of the top 15 most populous countries.</p>`
                : `<p>Oops, ${countryName} is not in the top 15. Keep trying!</p>`;

            if (infoPanelRef.current) {
                infoPanelRef.current.innerHTML = `${title}${message}<p><strong>Estimated Population:</strong> ${formattedPopulation}</p>`;
            }
        }

        function handleMouseOver(event, d) {
            const countryName = d.properties.name || "Unknown";
            tooltip
                .style("opacity", 1)
                .html(`<strong>${countryName}</strong>`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");
        }

        function handleMouseOut() {
            tooltip.style("opacity", 0);
        }

        const restartButton = document.getElementById('restartBtn-game');
        if (restartButton) {
            restartButton.addEventListener('click', startGame);
        }

        initMap();

        // Función de limpieza para cuando el componente se desmonte
        return () => {
            if (restartButton) {
                restartButton.removeEventListener('click', startGame);
            }
            d3.select(svgRef.current).selectAll("*").remove(); // Limpia el SVG
        };

    }, []); // El array vacío asegura que este efecto se ejecute solo una vez

    return (
        <div className="guess-the-country-container">
            <h1>🗺️ Guess the 15 Most Populous Countries</h1>

            <div className="game-ui">
                <div className="game-stat">
                    <div className="game-stat-label">Score</div>
                    <div ref={scoreRef} className="game-stat-value">0</div>
                </div>
                <div className="game-stat">
                    <div className="game-stat-label">Countries Left</div>
                    <div ref={remainingRef} className="game-stat-value">15</div>
                </div>
                <button className="btn" id="restartBtn-game">🔄 Restart Game</button>
            </div>

            <div className="map-container">
                <div id="loading-game" className="loading">🌍 Loading world map...</div>
                <svg ref={svgRef} id="worldMap"></svg>
            </div>

            <div ref={tooltipRef} className="tooltip"></div>

            <div ref={infoPanelRef} className="info-panel">
                {/* El contenido se generará con JavaScript */}
            </div>
        </div>
    );
};

export default GuessTheCountry;
</file>

<file path="src/components/juegos/SuperMarcos.css">
/* src/components/juegos/SuperMarcos.css */

.super-marcos-body {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #87CEEB; /* Sky blue background */
    font-family: Arial, sans-serif;
    padding: 20px;
}

.game-container {
    position: relative;
    text-align: center;
}

.game-title {
    color: #FF6B35;
    font-size: 48px;
    margin-bottom: 20px;
    text-shadow: 3px 3px 0px #000;
    font-weight: bold;
}

.gameCanvas {
    border: 2px solid #000;
    background-color: #FFFFFF;
    max-width: 100%; /* Para hacerlo responsivo */
    height: auto;
}

.instructions {
    margin-top: 15px;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    font-size: 14px;
    color: #333;
    border: 1px solid #ccc;
    display: inline-block;
    text-align: left;
}
</file>

<file path="src/components/juegos/SuperMarcos.js">
import React, { useRef, useEffect } from 'react';
import './SuperMarcos.css';

const SuperMarcos = () => {
    const canvasRef = useRef(null);
    const animationFrameId = useRef(null);
    const logic = useRef({
        gameState: 'menu',
        currentLevel: 1,
        maxLevel: 3,
        lives: 3,
        score: 0,
        coins: 0,
        powerUpActive: false,
        powerUpTimer: 0,
        wallJumpAvailable: false,
        onWall: false,
        wallSide: 0,
        levelCompleted: false,
        levelTransitionTimer: 0,
        lasers: [],
        LASER_COOLDOWN_TIME: 20,
        laserCooldown: 0,
        particles: [],
        player: {
            x: 50, y: 500, width: 50, height: 50, color: '#4A90E2',
            velocityX: 0, velocityY: 0, jumping: false, speed: 6, jumpStrength: 25, gravity: 1.2,
            invincible: false, invincibleTimer: 0, dashAvailable: true, dashCooldown: 0, wallSliding: false, lastDirection: 1
        },
        camera: { x: 0, y: 0 },
        worldWidth: 4000,
        worldHeight: 600,
        levels: [
            // --- NIVEL 1 ---
            {
                platforms: [
                    { x: 0, y: 550, width: 150, height: 20, color: '#A0522D' },
                    { x: 200, y: 400, width: 200, height: 20, color: '#A0522D' },
                    { x: 500, y: 300, width: 150, height: 20, color: '#A0522D' },
                    { x: 800, y: 450, width: 200, height: 20, color: '#A0522D' },
                    { x: 1100, y: 350, width: 150, height: 20, color: '#A0522D' },
                    { x: 1400, y: 250, width: 200, height: 20, color: '#A0522D' },
                    { x: 1700, y: 400, width: 250, height: 20, color: '#A0522D' },
                    { x: 2100, y: 300, width: 150, height: 20, color: '#A0522D' },
                    { x: 2500, y: 450, width: 200, height: 20, color: '#A0522D' },
                    { x: 2800, y: 280, width: 300, height: 20, color: '#A0522D' },
                    { x: 3200, y: 350, width: 200, height: 20, color: '#A0522D' },
                    { x: 3600, y: 250, width: 200, height: 20, color: '#A0522D' }
                ],
                coins: [
                    { x: 250, y: 350, width: 20, height: 20, collected: false, value: 50 },
                    { x: 550, y: 250, width: 20, height: 20, collected: false, value: 50 },
                    { x: 850, y: 400, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1150, y: 300, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1450, y: 200, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1750, y: 350, width: 20, height: 20, collected: false, value: 50 },
                    { x: 2150, y: 250, width: 20, height: 20, collected: false, value: 50 },
                    { x: 2550, y: 400, width: 20, height: 20, collected: false, value: 50 },
                    { x: 2850, y: 150, width: 20, height: 20, collected: false, value: 50 },
                    { x: 3250, y: 300, width: 20, height: 20, collected: false, value: 50 },
                    { x: 3650, y: 200, width: 20, height: 20, collected: false, value: 50 }
                ],
                powerUps: [
                    { x: 1200, y: 180, width: 30, height: 30, type: 'doubleJump', collected: false },
                    { x: 2400, y: 380, width: 30, height: 30, type: 'speedBoost', collected: false }
                ],
                enemies: [
                    { x: 300, y: 360, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 200, platformEnd: 400, health: 1 },
                    { x: 600, y: 260, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 500, platformEnd: 650, health: 1 },
                    { x: 1200, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 1100, platformEnd: 1250, health: 1 },
                    { x: 1800, y: 350, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 1700, platformEnd: 1950, health: 1 },
                    { x: 2400, y: 410, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 2300, platformEnd: 2500, health: 1 },
                    { x: 3000, y: 160, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 2800, platformEnd: 3100, health: 1 },
                    { x: 3400, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 3200, platformEnd: 3400, health: 1 },
                    { x: 800, y: 410, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 800, platformEnd: 1000, health: 1 },
                    { x: 1100, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 1100, platformEnd: 1250, health: 1 },
                    { x: 1400, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 1400, platformEnd: 1600, health: 1 },
                    { x: 2100, y: 260, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 2100, platformEnd: 2250, health: 1 },
                    { x: 2500, y: 410, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 2500, platformEnd: 2700, health: 1 },
                    { x: 3200, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 3200, platformEnd: 3400, health: 1 },
                    { x: 3600, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 3600, platformEnd: 3800, health: 1 },
                    { x: 400, y: 200, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 150, endY: 300, health: 1 },
                    { x: 900, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -1, alive: true, type: 'flying', startY: 100, endY: 250, health: 1 },
                    { x: 1500, y: 100, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 80, endY: 200, health: 1 },
                    { x: 2200, y: 200, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -1, alive: true, type: 'flying', startY: 150, endY: 280, health: 1 },
                    { x: 2900, y: 80, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 60, endY: 180, health: 1 },
                    { x: 3300, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -1, alive: true, type: 'flying', startY: 120, endY: 220, health: 1 },
                    { x: 3700, y: 120, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 100, endY: 180, health: 1 }
                ],
                goal: { x: 3900, y: 500, width: 50, height: 50, color: '#FFD700' }
            },
            // --- NIVEL 2 ---
            {
                platforms: [
                    { x: 0, y: 550, width: 150, height: 20, color: '#A0522D' },
                    { x: 150, y: 450, width: 150, height: 20, color: '#A0522D' },
                    { x: 400, y: 350, width: 200, height: 20, color: '#A0522D' },
                    { x: 700, y: 250, width: 180, height: 20, color: '#A0522D' },
                    { x: 1000, y: 400, width: 120, height: 20, color: '#A0522D' },
                    { x: 1300, y: 300, width: 250, height: 20, color: '#A0522D' },
                    { x: 1600, y: 200, width: 150, height: 20, color: '#A0522D' },
                    { x: 1900, y: 350, width: 200, height: 20, color: '#A0522D' },
                    { x: 2200, y: 450, width: 180, height: 20, color: '#A0522D' },
                    { x: 2500, y: 250, width: 200, height: 20, color: '#A0522D' },
                    { x: 2800, y: 300, width: 150, height: 20, color: '#A0522D' },
                    { x: 3100, y: 400, width: 200, height: 20, color: '#A0522D' },
                    { x: 3400, y: 250, width: 180, height: 20, color: '#A0522D' },
                    { x: 3700, y: 350, width: 200, height: 20, color: '#A0522D' }
                ],
                coins: [
                    { x: 200, y: 400, width: 20, height: 20, collected: false, value: 50 },
                    { x: 450, y: 300, width: 20, height: 20, collected: false, value: 50 },
                    { x: 750, y: 200, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1050, y: 350, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1350, y: 250, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1650, y: 150, width: 20, height: 20, collected: false, value: 50 },
                    { x: 1950, y: 300, width: 20, height: 20, collected: false, value: 50 },
                    { x: 2250, y: 400, width: 20, height: 20, collected: false, value: 50 },
                    { x: 2550, y: 100, width: 20, height: 20, collected: false, value: 50 },
                    { x: 2850, y: 250, width: 20, height: 20, collected: false, value: 50 },
                    { x: 3150, y: 350, width: 20, height: 20, collected: false, value: 50 },
                    { x: 3450, y: 200, width: 20, height: 20, collected: false, value: 50 },
                    { x: 3750, y: 300, width: 20, height: 20, collected: false, value: 50 }
                ],
                powerUps: [
                    { x: 800, y: 200, width: 30, height: 30, type: 'doubleJump', collected: false },
                    { x: 2000, y: 300, width: 30, height: 30, type: 'speedBoost', collected: false },
                    { x: 3200, y: 200, width: 30, height: 30, type: 'doubleJump', collected: false }
                ],
                enemies: [
                    { x: 200, y: 410, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 150, platformEnd: 300, health: 1 },
                    { x: 450, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 400, platformEnd: 600, health: 1 },
                    { x: 750, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 700, platformEnd: 880, health: 1 },
                    { x: 1050, y: 360, width: 40, height: 40, color: '#FF4444', velocityX: -1, velocityY: 0, alive: true, type: 'ground', platformStart: 1000, platformEnd: 1120, health: 1 },
                    { x: 1350, y: 260, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 1300, platformEnd: 1550, health: 1 },
                    { x: 1650, y: 160, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 1600, platformEnd: 1750, health: 1 },
                    { x: 1950, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 1900, platformEnd: 2100, health: 1 },
                    { x: 2250, y: 410, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 2200, platformEnd: 2380, health: 1 },
                    { x: 2550, y: 110, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 2500, platformEnd: 2700, health: 1 },
                    { x: 2850, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 2800, platformEnd: 2950, health: 1 },
                    { x: 3150, y: 360, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 3100, platformEnd: 3300, health: 1 },
                    { x: 3450, y: 160, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 3400, platformEnd: 3580, health: 1 },
                    { x: 3750, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: 2, velocityY: 0, alive: true, type: 'ground', platformStart: 3700, platformEnd: 3900, health: 1 },
                    { x: 300, y: 180, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 120, endY: 250, health: 1 },
                    { x: 600, y: 120, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -1, alive: true, type: 'flying', startY: 80, endY: 180, health: 1 },
                    { x: 1200, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 100, endY: 220, health: 1 },
                    { x: 1800, y: 100, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -1, alive: true, type: 'flying', startY: 60, endY: 160, health: 1 },
                    { x: 2400, y: 200, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 150, endY: 280, health: 1 },
                    { x: 3000, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -1, alive: true, type: 'flying', startY: 100, endY: 200, health: 1 },
                    { x: 3600, y: 180, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 1, alive: true, type: 'flying', startY: 120, endY: 240, health: 1 }
                ],
                goal: { x: 3900, y: 500, width: 50, height: 50, color: '#FFD700' }
            },
            // --- NIVEL 3 ---
            {
                platforms: [
                    { x: 0, y: 550, width: 150, height: 20, color: '#A0522D' },
                    { x: 100, y: 400, width: 100, height: 20, color: '#A0522D' },
                    { x: 300, y: 300, width: 150, height: 20, color: '#A0522D' },
                    { x: 550, y: 200, width: 120, height: 20, color: '#A0522D' },
                    { x: 800, y: 350, width: 200, height: 20, color: '#A0522D' },
                    { x: 1100, y: 250, width: 150, height: 20, color: '#A0522D' },
                    { x: 1400, y: 150, width: 100, height: 20, color: '#A0522D' },
                    { x: 1600, y: 300, width: 180, height: 20, color: '#A0522D' },
                    { x: 1900, y: 200, width: 150, height: 20, color: '#A0522D' },
                    { x: 2200, y: 350, width: 200, height: 20, color: '#A0522D' },
                    { x: 2500, y: 250, width: 150, height: 20, color: '#A0522D' },
                    { x: 2800, y: 150, width: 120, height: 20, color: '#A0522D' },
                    { x: 3100, y: 300, width: 200, height: 20, color: '#A0522D' },
                    { x: 3400, y: 200, width: 150, height: 20, color: '#A0522D' },
                    { x: 3700, y: 350, width: 200, height: 20, color: '#A0522D' }
                ],
                coins: [
                    { x: 150, y: 350, width: 20, height: 20, collected: false, value: 100 },
                    { x: 350, y: 250, width: 20, height: 20, collected: false, value: 100 },
                    { x: 600, y: 150, width: 20, height: 20, collected: false, value: 100 },
                    { x: 850, y: 300, width: 20, height: 20, collected: false, value: 100 },
                    { x: 1150, y: 200, width: 20, height: 20, collected: false, value: 100 },
                    { x: 1450, y: 100, width: 20, height: 20, collected: false, value: 100 },
                    { x: 1650, y: 250, width: 20, height: 20, collected: false, value: 100 },
                    { x: 1950, y: 150, width: 20, height: 20, collected: false, value: 100 },
                    { x: 2250, y: 300, width: 20, height: 20, collected: false, value: 100 },
                    { x: 2550, y: 200, width: 20, height: 20, collected: false, value: 100 },
                    { x: 2850, y: 100, width: 20, height: 20, collected: false, value: 100 },
                    { x: 3150, y: 250, width: 20, height: 20, collected: false, value: 100 },
                    { x: 3450, y: 150, width: 20, height: 20, collected: false, value: 100 },
                    { x: 3750, y: 300, width: 20, height: 20, collected: false, value: 100 }
                ],
                powerUps: [
                    { x: 600, y: 150, width: 30, height: 30, type: 'doubleJump', collected: false },
                    { x: 1400, y: 100, width: 30, height: 30, type: 'speedBoost', collected: false },
                    { x: 2200, y: 300, width: 30, height: 30, type: 'doubleJump', collected: false },
                    { x: 3100, y: 250, width: 30, height: 30, type: 'speedBoost', collected: false }
                ],
                enemies: [
                    { x: 150, y: 360, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 100, platformEnd: 200, health: 1 },
                    { x: 350, y: 260, width: 40, height: 40, color: '#FF4444', velocityX: -3, velocityY: 0, alive: true, type: 'ground', platformStart: 300, platformEnd: 450, health: 1 },
                    { x: 600, y: 160, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 550, platformEnd: 670, health: 1 },
                    { x: 850, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: -2, velocityY: 0, alive: true, type: 'ground', platformStart: 800, platformEnd: 1000, health: 1 },
                    { x: 1150, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 1100, platformEnd: 1250, health: 1 },
                    { x: 1450, y: 110, width: 40, height: 40, color: '#FF4444', velocityX: -3, velocityY: 0, alive: true, type: 'ground', platformStart: 1400, platformEnd: 1500, health: 1 },
                    { x: 1650, y: 260, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 1600, platformEnd: 1780, health: 1 },
                    { x: 1950, y: 160, width: 40, height: 40, color: '#FF4444', velocityX: -3, velocityY: 0, alive: true, type: 'ground', platformStart: 1900, platformEnd: 2050, health: 1 },
                    { x: 2250, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 2200, platformEnd: 2350, health: 1 },
                    { x: 2550, y: 210, width: 40, height: 40, color: '#FF4444', velocityX: -3, velocityY: 0, alive: true, type: 'ground', platformStart: 2500, platformEnd: 2650, health: 1 },
                    { x: 2850, y: 110, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 2800, platformEnd: 2920, health: 1 },
                    { x: 3150, y: 260, width: 40, height: 40, color: '#FF4444', velocityX: -3, velocityY: 0, alive: true, type: 'ground', platformStart: 3100, platformEnd: 3300, health: 1 },
                    { x: 3450, y: 160, width: 40, height: 40, color: '#FF4444', velocityX: 3, velocityY: 0, alive: true, type: 'ground', platformStart: 3400, platformEnd: 3550, health: 1 },
                    { x: 3750, y: 310, width: 40, height: 40, color: '#FF4444', velocityX: -3, velocityY: 0, alive: true, type: 'ground', platformStart: 3700, platformEnd: 3900, health: 1 },
                    { x: 200, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 2, alive: true, type: 'flying', startY: 100, endY: 200, health: 1 },
                    { x: 500, y: 100, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -2, alive: true, type: 'flying', startY: 60, endY: 150, health: 1 },
                    { x: 900, y: 120, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 2, alive: true, type: 'flying', startY: 80, endY: 180, health: 1 },
                    { x: 1300, y: 80, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -2, alive: true, type: 'flying', startY: 40, endY: 120, health: 1 },
                    { x: 1700, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 2, alive: true, type: 'flying', startY: 100, endY: 200, health: 1 },
                    { x: 2100, y: 100, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -2, alive: true, type: 'flying', startY: 60, endY: 150, health: 1 },
                    { x: 2500, y: 120, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 2, alive: true, type: 'flying', startY: 80, endY: 180, health: 1 },
                    { x: 2900, y: 80, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -2, alive: true, type: 'flying', startY: 40, endY: 120, health: 1 },
                    { x: 3300, y: 150, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: 2, alive: true, type: 'flying', startY: 100, endY: 200, health: 1 },
                    { x: 3700, y: 100, width: 35, height: 35, color: '#9B59B6', velocityX: 0, velocityY: -2, alive: true, type: 'flying', startY: 60, endY: 150, health: 1 }
                ],
                goal: { x: 3900, y: 500, width: 50, height: 50, color: '#FFD700' }
            }
        ],
        platforms: [],
        coinsArray: [],
        powerUps: [],
        enemies: [],
        goal: {},
        keys: {},
        keyPressed: {},
    });

    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const l = logic.current;

        // --- Funciones auxiliares ---
        function createParticle(x, y, color, type = 'explosion') {
            for (let i = 0; i < 8; i++) {
                l.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 60, maxLife: 60,
                    color, size: Math.random() * 4 + 2, type
                });
            }
        }
        function updateParticles() {
            for (let i = l.particles.length - 1; i >= 0; i--) {
                let p = l.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                if (p.life <= 0) l.particles.splice(i, 1);
            }
        }
        function drawParticles() {
            l.particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - l.camera.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }
        function resetGame() {
            l.lives = 3; l.score = 0; l.coins = 0; l.gameState = 'playing';
            l.powerUpActive = false; l.powerUpTimer = 0; l.wallJumpAvailable = false; l.onWall = false;
            l.particles = []; l.lasers = []; l.laserCooldown = 0;
            Object.assign(l.player, { x: 50, y: 500, velocityX: 0, velocityY: 0, invincible: false, invincibleTimer: 0, dashAvailable: true, dashCooldown: 0, wallSliding: false, lastDirection: 1 });
            l.camera.x = 0; l.camera.y = 0;
            loadLevel(l.currentLevel);
        }
        function loadLevel(levelNum) {
            if (levelNum < 1 || levelNum > l.levels.length) return;
            l.currentLevel = levelNum;
            const levelData = l.levels[l.currentLevel - 1];
            if (!levelData) return;
            l.platforms = levelData.platforms;
            l.coinsArray = JSON.parse(JSON.stringify(levelData.coins));
            l.powerUps = JSON.parse(JSON.stringify(levelData.powerUps));
            l.enemies = JSON.parse(JSON.stringify(levelData.enemies));
            l.goal = levelData.goal;
            l.coinsArray.forEach(coin => coin.collected = false);
            l.powerUps.forEach(powerUp => powerUp.collected = false);
            l.enemies.forEach(enemy => { enemy.alive = true; enemy.health = 1; });
        }
        function nextLevel() {
            if (l.currentLevel < l.maxLevel) {
                l.levelCompleted = true;
                l.levelTransitionTimer = 60;
            } else {
                l.gameState = 'won';
            }
        }

        // --- Event listeners completos ---
        const handleKeyDown = (e) => {
            // Prevenir scroll solo si el juego está en modo playing y la tecla es relevante
            const keysToPrevent = [' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            if (l.gameState === 'playing' && keysToPrevent.includes(e.key)) {
                e.preventDefault();
            }
            if (!l.keys[e.key]) l.keyPressed[e.key] = true;
            l.keys[e.key] = true;

            // Disparo (espacio)
            if (e.key === ' ' && l.gameState === 'playing') {
                if (l.laserCooldown <= 0) {
                    const pistolBarrelWidth = 15;
                    const laserWidth = 15;
                    const laserHeight = 5;
                    const pistolBarrelHeight = 7;
                    const laserY = l.player.y + l.player.height / 2 + (pistolBarrelHeight / 2) - (laserHeight / 2);
                    l.lasers.push({
                        x: l.player.x + (l.player.lastDirection === 1 ? l.player.width : -pistolBarrelWidth),
                        y: laserY,
                        width: laserWidth,
                        height: laserHeight,
                        color: '#FF00FF',
                        velocityX: 15 * l.player.lastDirection
                    });
                    l.laserCooldown = l.LASER_COOLDOWN_TIME;
                }
            }
            // Pausa (P)
            if ((e.key === 'p' || e.key === 'P') && (l.gameState === 'playing' || l.gameState === 'paused')) {
                l.gameState = l.gameState === 'playing' ? 'paused' : 'playing';
            }
            // Reinicio (R)
            if ((e.key === 'r' || e.key === 'R')) {
                resetGame();
            }
            // Empezar desde menú (ENTER)
            if (e.key === 'Enter' && l.gameState === 'menu') {
                l.gameState = 'playing';
            }
            // Menú/pausa (ESC)
            if (e.key === 'Escape') {
                if (l.gameState === 'playing') l.gameState = 'paused';
                else if (l.gameState === 'paused') l.gameState = 'playing';
                else if (l.gameState === 'menu') l.gameState = 'menu';
            }
        };
        const handleKeyUp = (e) => {
            l.keys[e.key] = false;
            l.keyPressed[e.key] = false;
        };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);

        // --- Lógica principal del juego ---
        function update() {
            if (l.gameState !== 'playing') return;
            updateParticles();

            // Level transition
            if (l.levelCompleted) {
                l.levelTransitionTimer--;
                if (l.levelTransitionTimer <= 0) {
                    l.currentLevel++;
                    loadLevel(l.currentLevel);
                    l.gameState = 'playing';
                    l.levelCompleted = false;
                    l.levelTransitionTimer = 0;
                    Object.assign(l.player, { x: 50, y: 500, velocityX: 0, velocityY: 0, invincible: false, invincibleTimer: 0, dashAvailable: true, dashCooldown: 0, wallSliding: false, lastDirection: 1 });
                    l.lasers = [];
                    l.laserCooldown = 0;
                }
                return;
            }

            // Timers
            if (l.player.invincible) {
                l.player.invincibleTimer--;
                if (l.player.invincibleTimer <= 0) l.player.invincible = false;
            }
            if (l.powerUpActive) {
                l.powerUpTimer--;
                if (l.powerUpTimer <= 0) l.powerUpActive = false;
            }
            if (l.player.dashCooldown > 0) l.player.dashCooldown--;
            if (l.laserCooldown > 0) l.laserCooldown--;

            // Wall detection
            l.onWall = false;
            l.wallSide = 0;
            for (let plat of l.platforms) {
                if (l.player.x <= plat.x && l.player.x + l.player.width >= plat.x && l.player.y < plat.y + plat.height && l.player.y + l.player.height > plat.y) {
                    l.onWall = true; l.wallSide = -1; break;
                }
                if (l.player.x <= plat.x + plat.width && l.player.x + l.player.width >= plat.x + plat.width && l.player.y < plat.y + plat.height && l.player.y + l.player.height > plat.y) {
                    l.onWall = true; l.wallSide = 1; break;
                }
            }

            // Movimiento horizontal
            l.player.velocityX = 0;
            if (l.keys['ArrowLeft']) { l.player.velocityX = -l.player.speed; l.player.lastDirection = -1; }
            if (l.keys['ArrowRight']) { l.player.velocityX = l.player.speed; l.player.lastDirection = 1; }

            // Wall sliding
            if (l.onWall && !l.player.jumping && l.player.velocityY > 0) {
                l.player.wallSliding = true;
                l.player.velocityY = Math.min(l.player.velocityY, 2);
            } else {
                l.player.wallSliding = false;
            }

            // Salto y wall jump
            if (l.keyPressed['ArrowUp']) {
                if (!l.player.jumping && !l.player.wallSliding) {
                    l.player.velocityY = -l.player.jumpStrength;
                    l.player.jumping = true;
                    createParticle(l.player.x + l.player.width / 2, l.player.y + l.player.height, '#4A90E2', 'jump');
                } else if (l.player.wallSliding) {
                    l.player.velocityY = -l.player.jumpStrength * 0.7;
                    l.player.velocityX = l.wallSide * l.player.speed * 1.5;
                    l.player.wallSliding = false;
                    l.player.jumping = true;
                    createParticle(l.player.x + l.player.width / 2, l.player.y + l.player.height, '#FF6B35', 'wallJump');
                }
            }

            // Dash
            if (l.keyPressed['Shift'] && l.player.dashAvailable && l.player.dashCooldown <= 0) {
                l.player.velocityX *= 3;
                l.player.dashAvailable = false;
                l.player.dashCooldown = 120;
                createParticle(l.player.x + l.player.width / 2, l.player.y + l.player.height / 2, '#FFD700', 'dash');
            }

            // Gravedad
            if (!l.player.wallSliding) l.player.velocityY += l.player.gravity;

            // Actualizar posición
            l.player.y += l.player.velocityY;
            l.player.x += l.player.velocityX;
            if (l.player.x < 0) l.player.x = 0;
            if (l.player.x + l.player.width > l.worldWidth) l.player.x = l.worldWidth - l.player.width;

            // Scroll cámara
            if (l.player.x < l.camera.x + 200) l.camera.x = l.player.x - 200;
            if (l.camera.x < 0) l.camera.x = 0;
            if (l.player.x > l.camera.x + canvas.width - 200) l.camera.x = l.player.x - (canvas.width - 200);
            if (l.camera.x > l.worldWidth - canvas.width) l.camera.x = l.worldWidth - canvas.width;

            // Colisiones con monedas
            l.coinsArray.forEach(coin => {
                if (!coin.collected && l.player.x < coin.x + coin.width && l.player.x + l.player.width > coin.x && l.player.y < coin.y + coin.height && l.player.y + l.player.height > coin.y) {
                    coin.collected = true;
                    l.coins++;
                    l.score += coin.value;
                    createParticle(coin.x + coin.width / 2, coin.y + coin.height / 2, '#FFD700', 'coin');
                }
            });

            // Colisiones con power-ups
            l.powerUps.forEach(powerUp => {
                if (!powerUp.collected && l.player.x < powerUp.x + powerUp.width && l.player.x + l.player.width > powerUp.x && l.player.y < powerUp.y + powerUp.height && l.player.y + l.player.height > powerUp.y) {
                    powerUp.collected = true;
                    if (powerUp.type === 'doubleJump') {
                        createParticle(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2, '#FFD700', 'powerUp');
                    } else if (powerUp.type === 'speedBoost') {
                        l.powerUpActive = true;
                        l.powerUpTimer = 300;
                        l.player.speed = 8;
                        createParticle(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2, '#FF6B35', 'powerUp');
                    }
                }
            });
            if (!l.powerUpActive && l.player.speed > 6) l.player.speed = 6;

            // Actualizar lasers
            for (let i = l.lasers.length - 1; i >= 0; i--) {
                let laser = l.lasers[i];
                laser.x += laser.velocityX;
                if (laser.x < l.camera.x - 50 || laser.x > l.camera.x + canvas.width + 50) {
                    l.lasers.splice(i, 1);
                    continue;
                }
                for (let enemy of l.enemies) {
                    if (enemy.alive && laser.x < enemy.x + enemy.width && laser.x + laser.width > enemy.x && laser.y < enemy.y + enemy.height && laser.y + laser.height > enemy.y) {
                        enemy.health--;
                        if (enemy.health <= 0) {
                            enemy.alive = false;
                            createParticle(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 'explosion');
                        }
                        l.score += 100;
                        createParticle(laser.x + laser.width / 2, laser.y + laser.height / 2, '#FF00FF', 'laserHit');
                        l.lasers.splice(i, 1);
                        break;
                    }
                }
            }

            // Actualizar enemigos
            for (let enemy of l.enemies) {
                if (enemy.alive) {
                    if (enemy.type === 'ground') {
                        enemy.x += enemy.velocityX;
                        if (enemy.x <= enemy.platformStart || enemy.x >= enemy.platformEnd - enemy.width) enemy.velocityX *= -1;
                    } else if (enemy.type === 'flying') {
                        enemy.y += enemy.velocityY;
                        if (enemy.y <= enemy.startY || enemy.y >= enemy.endY) enemy.velocityY *= -1;
                    }
                    // Colisión con jugador
                    if (!l.player.invincible && l.player.x < enemy.x + enemy.width && l.player.x + l.player.width > enemy.x && l.player.y < enemy.y + enemy.height && l.player.y + l.player.height > enemy.y) {
                        if (l.player.velocityY > 0 && l.player.y + l.player.height - l.player.velocityY <= enemy.y) {
                            enemy.health--;
                            if (enemy.health <= 0) {
                                enemy.alive = false;
                                createParticle(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 'explosion');
                            }
                            l.score += 100;
                            l.player.velocityY = -l.player.jumpStrength / 2;
                        } else {
                            l.lives--;
                            if (l.lives <= 0) {
                                l.gameState = 'gameOver';
                            } else {
                                Object.assign(l.player, { x: 50, y: 500, velocityX: 0, velocityY: 0, invincible: true, invincibleTimer: 120, dashAvailable: true, dashCooldown: 0, wallSliding: false, lastDirection: 1 });
                                l.camera.x = 0;
                                createParticle(l.player.x + l.player.width / 2, l.player.y + l.player.height / 2, '#FF4444', 'hit');
                            }
                        }
                    }
                }
            }

            // Colisión con meta
            if (!l.levelCompleted && l.player.x < l.goal.x + l.goal.width && l.player.x + l.player.width > l.goal.x && l.player.y < l.goal.y + l.goal.height && l.player.y + l.player.height > l.goal.y) {
                l.score += 500;
                createParticle(l.goal.x + l.goal.width / 2, l.goal.y + l.goal.height / 2, '#FFD700', 'goal');
                nextLevel();
            }

            // Colisiones con plataformas (suelo)
            l.player.jumping = true;
            for (let plat of l.platforms) {
                if (l.player.x < plat.x + plat.width && l.player.x + l.player.width > plat.x && l.player.y + l.player.height <= plat.y + l.player.velocityY && l.player.y + l.player.height >= plat.y) {
                    if (l.player.velocityY > 0) {
                        l.player.y = plat.y - l.player.height;
                        l.player.velocityY = 0;
                        l.player.jumping = false;
                    }
                }
            }

            // Si el jugador se cae
            if (l.player.y > canvas.height) {
                l.lives--;
                createParticle(l.player.x + l.player.width / 2, l.player.y, '#FF4444', 'hit');
                if (l.lives <= 0) {
                    l.gameState = 'gameOver';
                } else {
                    Object.assign(l.player, { x: 50, y: 500, velocityX: 0, velocityY: 0, invincible: true, invincibleTimer: 120, dashAvailable: true, dashCooldown: 0, wallSliding: false, lastDirection: 1 });
                    l.camera.x = 0;
                }
            }

            // Limpiar keyPressed
            Object.keys(l.keyPressed).forEach(k => l.keyPressed[k] = false);
        }

        // --- Renderizado completo ---
        function drawMenu() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#4A90E2');
            gradient.addColorStop(1, '#87CEEB');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FF6B35';
            ctx.font = 'bold 64px Arial';
            ctx.fillText('SUPER MARCOS', canvas.width / 2 - 250, canvas.height / 2 - 100);
            ctx.fillStyle = '#FFF';
            ctx.font = '24px Arial';
            ctx.fillText('The Ultimate Platformer Adventure', canvas.width / 2 - 180, canvas.height / 2 - 50);
            ctx.font = 'bold 32px Arial';
            ctx.fillText('Press ENTER to Start', canvas.width / 2 - 150, canvas.height / 2 + 50);
            ctx.font = '20px Arial';
            ctx.fillText('Controls: Arrow Keys (Move) | Spacebar (Jump) | Shift (Dash)', canvas.width / 2 - 200, canvas.height / 2 + 100);
            ctx.fillText('P: Pause | R: Restart | ESC: Menu', canvas.width / 2 - 150, canvas.height / 2 + 130);
            const time = Date.now() * 0.001;
            for (let i = 0; i < 5; i++) {
                const x = (i * 150 + time * 50) % (canvas.width + 100);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(x, canvas.height - 50, 100, 20);
            }
        }
        function drawUI() {
            ctx.fillStyle = '#000';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`Level: ${l.currentLevel}`, 10, 30);
            ctx.fillText(`Score: ${l.score}`, 10, 60);
            ctx.fillText(`Lives: ${l.lives}`, 10, 90);
            ctx.fillText(`Coins: ${l.coins}`, 10, 120);
            ctx.fillStyle = '#FF4444';
            for (let i = 0; i < l.lives; i++) ctx.fillText('♥', 80 + i * 25, 90);
            if (l.powerUpActive) {
                ctx.fillStyle = '#FF6B35';
                ctx.fillText('SPEED BOOST!', canvas.width - 150, 30);
            }
            if (l.levelCompleted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 48px Arial';
                ctx.fillText('LEVEL COMPLETE!', canvas.width / 2 - 200, canvas.height / 2);
                ctx.fillStyle = '#FFF';
                ctx.font = '20px Arial';
                ctx.fillText(`Level ${l.currentLevel} Score: ${l.score}`, canvas.width / 2 - 100, canvas.height / 2 + 40);
                ctx.fillText('Loading next level...', canvas.width / 2 - 100, canvas.height / 2 + 70);
            }
            if (l.gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 48px Arial';
                ctx.fillText('PAUSED', canvas.width / 2 - 120, canvas.height / 2);
                ctx.font = '20px Arial';
                ctx.fillText('Press P to resume', canvas.width / 2 - 100, canvas.height / 2 + 40);
            }
            if (l.gameState === 'gameOver') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FF4444';
                ctx.font = 'bold 48px Arial';
                ctx.fillText('GAME OVER', canvas.width / 2 - 150, canvas.height / 2);
                ctx.fillStyle = '#FFF';
                ctx.font = '20px Arial';
                ctx.fillText(`Final Score: ${l.score}`, canvas.width / 2 - 80, canvas.height / 2 + 40);
                ctx.fillText('Press R to restart', canvas.width / 2 - 80, canvas.height / 2 + 70);
            }
            if (l.gameState === 'won') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 48px Arial';
                ctx.fillText('CONGRATULATIONS!', canvas.width / 2 - 250, canvas.height / 2);
                ctx.fillStyle = '#FFF';
                ctx.font = '20px Arial';
                ctx.fillText(`Final Score: ${l.score}`, canvas.width / 2 - 80, canvas.height / 2 + 40);
                ctx.fillText(`Coins Collected: ${l.coins}`, canvas.width / 2 - 80, canvas.height / 2 + 70);
                ctx.fillText('You completed all levels!', canvas.width / 2 - 100, canvas.height / 2 + 100);
                ctx.fillText('Press R to restart', canvas.width / 2 - 80, canvas.height / 2 + 130);
            }
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (l.gameState === 'menu') { drawMenu(); return; }
            // Fondo cielo
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Nubes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const cloudX = (i * 300 - l.camera.x * 0.2) % (canvas.width + 100);
                ctx.beginPath();
                ctx.arc(cloudX, 80 + i * 20, 30, 0, Math.PI * 2);
                ctx.arc(cloudX + 25, 80 + i * 20, 25, 0, Math.PI * 2);
                ctx.arc(cloudX + 50, 80 + i * 20, 20, 0, Math.PI * 2);
                ctx.fill();
            }
            // Colinas
            ctx.fillStyle = '#90EE90';
            for (let i = 0; i < 3; i++) {
                const hillX = (i * 400 - l.camera.x * 0.5) % (canvas.width + 200);
                ctx.beginPath();
                ctx.moveTo(hillX, canvas.height);
                ctx.quadraticCurveTo(hillX + 100, canvas.height - 100, hillX + 200, canvas.height);
                ctx.fill();
            }
            // Plataformas
            for (let plat of l.platforms) {
                ctx.fillStyle = plat.color;
                ctx.fillRect(plat.x - l.camera.x, plat.y, plat.width, plat.height);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(plat.x - l.camera.x, plat.y, plat.width, 5);
            }
            // Monedas
            l.coinsArray.forEach(coin => {
                if (!coin.collected) {
                    const time = Date.now() * 0.005;
                    const bounce = Math.sin(time) * 3;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x - l.camera.x + coin.width / 2, coin.y + coin.height / 2 + bounce, coin.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    if (Math.random() < 0.1) {
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(coin.x - l.camera.x + Math.random() * coin.width, coin.y + Math.random() * coin.height, 2, 2);
                    }
                }
            });
            // Power-ups
            l.powerUps.forEach(powerUp => {
                if (!powerUp.collected) {
                    const time = Date.now() * 0.01;
                    const pulse = Math.sin(time) * 0.3 + 0.7;
                    if (powerUp.type === 'doubleJump') ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
                    else if (powerUp.type === 'speedBoost') ctx.fillStyle = `rgba(255, 107, 53, ${pulse})`;
                    ctx.fillRect(powerUp.x - l.camera.x, powerUp.y, powerUp.width, powerUp.height);
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(powerUp.x - l.camera.x, powerUp.y, powerUp.width, powerUp.height);
                }
            });
            // Enemigos
            for (let enemy of l.enemies) {
                if (enemy.alive) {
                    ctx.fillStyle = enemy.color;
                    if (enemy.type === 'ground') {
                        ctx.fillRect(enemy.x - l.camera.x, enemy.y, enemy.width, enemy.height);
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(enemy.x - l.camera.x + 8, enemy.y + 8, 6, 6);
                        ctx.fillRect(enemy.x - l.camera.x + 26, enemy.y + 8, 6, 6);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(enemy.x - l.camera.x + 10, enemy.y + 10, 2, 2);
                        ctx.fillRect(enemy.x - l.camera.x + 28, enemy.y + 10, 2, 2);
                    } else if (enemy.type === 'flying') {
                        ctx.fillRect(enemy.x - l.camera.x, enemy.y, enemy.width, enemy.height);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.fillRect(enemy.x - l.camera.x - 5, enemy.y + 5, 8, 15);
                        ctx.fillRect(enemy.x - l.camera.x + enemy.width - 3, enemy.y + 5, 8, 15);
                    }
                }
            }
            // Meta
            const goalTime = Date.now() * 0.003;
            const goalPulse = Math.sin(goalTime) * 0.2 + 0.8;
            ctx.fillStyle = `rgba(255, 215, 0, ${goalPulse})`;
            ctx.fillRect(l.goal.x - l.camera.x, l.goal.y, l.goal.width, l.goal.height);
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(l.goal.x - l.camera.x, l.goal.y, l.goal.width, l.goal.height);
            ctx.save();
            ctx.translate(l.goal.x - l.camera.x + l.goal.width / 2, l.goal.y + l.goal.height / 2);
            ctx.rotate(goalTime);
            ctx.fillStyle = '#FFF';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(-1, -15, 2, 30);
                ctx.rotate(Math.PI * 2 / 5);
            }
            ctx.restore();
            // Lasers
            for (let laser of l.lasers) {
                ctx.fillStyle = laser.color;
                ctx.fillRect(laser.x - l.camera.x, laser.y, laser.width, laser.height);
                ctx.shadowColor = laser.color;
                ctx.shadowBlur = 10;
                ctx.fillRect(laser.x - l.camera.x, laser.y, laser.width, laser.height);
                ctx.shadowBlur = 0;
            }
            // Partículas
            drawParticles();
            // Jugador
            if (!l.player.invincible || Math.floor(Date.now() / 100) % 2) {
                let playerColor = l.player.color;
                if (l.powerUpActive) playerColor = '#FFD700';
                if (l.player.wallSliding) playerColor = '#FF6B35';
                ctx.fillStyle = playerColor;
                ctx.fillRect(l.player.x - l.camera.x, l.player.y, l.player.width, l.player.height);
                // Detalles del jugador (ojos, sonrisa, pistola)
                const pX = l.player.x - l.camera.x;
                const pY = l.player.y;
                const pW = l.player.width;
                const pH = l.player.height;
                const eyeSize = 8;
                const pupilSize = 4;
                const eyeOffsetY = 15;
                const smileOffsetY = 35;
                const smileRadius = 7;
                const pistolBarrelWidth = 15;
                const pistolBarrelHeight = 7;
                const pistolHandleWidth = 8;
                const pistolHandleHeight = 10;
                if (l.player.lastDirection === 1) {
                    const eye1X = pX + pW - 28;
                    const eye2X = pX + pW - 16;
                    const pupil1X = pX + pW - 26;
                    const pupil2X = pX + pW - 14;
                    const smileX = pX + pW - 22;
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(eye1X, pY + eyeOffsetY, eyeSize, eyeSize);
                    ctx.fillRect(eye2X, pY + eyeOffsetY, eyeSize, eyeSize);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(pupil1X, pY + eyeOffsetY + 2, pupilSize, pupilSize);
                    ctx.fillRect(pupil2X, pY + eyeOffsetY + 2, pupilSize, pupilSize);
                    ctx.beginPath();
                    ctx.arc(smileX, pY + smileOffsetY, smileRadius, 0, Math.PI);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                    ctx.fillRect(pX + pW, pY + pH / 2, pistolBarrelWidth, pistolBarrelHeight);
                    ctx.fillRect(pX + pW - 5, pY + pH / 2 + pistolBarrelHeight, pistolHandleWidth, pistolHandleHeight);
                } else {
                    const eye1X = pX + 8;
                    const eye2X = pX + 20;
                    const pupil1X = pX + 10;
                    const pupil2X = pX + 22;
                    const smileX = pX + 16;
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(eye1X, pY + eyeOffsetY, eyeSize, eyeSize);
                    ctx.fillRect(eye2X, pY + eyeOffsetY, eyeSize, eyeSize);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(pupil1X, pY + eyeOffsetY + 2, pupilSize, pupilSize);
                    ctx.fillRect(pupil2X, pY + eyeOffsetY + 2, pupilSize, pupilSize);
                    ctx.beginPath();
                    ctx.arc(smileX, pY + smileOffsetY, smileRadius, 0, Math.PI);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                    ctx.fillRect(pX - pistolBarrelWidth, pY + pH / 2, pistolBarrelWidth, pistolBarrelHeight);
                    ctx.fillRect(pX - 3, pY + pH / 2 + pistolBarrelHeight, pistolHandleWidth, pistolHandleHeight);
                }
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(l.player.x - l.camera.x, l.player.y, l.player.width, l.player.height);
                if (l.player.wallSliding) {
                    ctx.fillStyle = 'rgba(255, 107, 53, 0.3)';
                    ctx.fillRect(l.player.x - l.camera.x, l.player.y, l.player.width, l.player.height);
                }
            }
            drawUI();
        }

        // --- Bucle principal ---
        function gameLoop() {
            update();
            draw();
            animationFrameId.current = requestAnimationFrame(gameLoop);
        }
        loadLevel(l.currentLevel);
        gameLoop();

        return () => {
            cancelAnimationFrame(animationFrameId.current);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        };
    }, []);

    return (
        <div className="super-marcos-body">
            <div className="game-container">
                <h1 className="game-title">Super Marcos</h1>
                <canvas ref={canvasRef} className="gameCanvas" width="800" height="600"></canvas>
                <div className="instructions">
                    <p><strong>🎮 Advanced Controls:</strong></p>
                    <p>Arrow Keys: Move | <strong>Arrow Up: Jump</strong> | <strong>Spacebar: Shoot</strong> | Shift: Dash</p>
                    <p>Wall Jump: Slide on wall + Arrow Up</p>
                    <p><strong>🎯 Game Features:</strong></p>
                    <p>Collect coins (gold) and power-ups (colored boxes)</p>
                    <p>Defeat enemies by jumping on them</p>
                    <p>Reach the golden goal to complete levels!</p>
                    <p><strong>⌨️ Menu Controls:</strong></p>
                    <p>P: Pause | R: Restart | ESC: Menu | ENTER: Start</p>
                </div>
            </div>
        </div>
    );
};

export default SuperMarcos;
</file>

<file path="public/manifest.json">
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="src/components/juegos/CarViewer.js">
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

function CarViewer() {
  const ref = useRef();
  const frameId = useRef();
  const modelRef = useRef();
  const [error, setError] = useState(null);
  const [loadingStatus, setLoadingStatus] = useState('');

  useEffect(() => {
    const currentRef = ref.current;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc);
    const camera = new THREE.PerspectiveCamera(65, currentRef.clientWidth / currentRef.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(currentRef.clientWidth, currentRef.clientHeight);
    currentRef.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;

    const loader = new GLTFLoader();

    // Función para cargar un modelo
    const loadModel = (url, position) => {
      setLoadingStatus(`Loading model...`);
      return new Promise((resolve, reject) => {
        loader.load(
          url,
          (gltf) => {
            const model = gltf.scene;
            model.position.set(...position);
            scene.add(model);
            setLoadingStatus(`Model loaded successfully`);
            resolve(model);
          },
          undefined,
          (error) => {
            console.error(`Error loading model:`, error);
            setError(`Error loading model: ${error.message}`);
            reject(error);
          }
        );
      });
    };

    loadModel('/coche3.glb', [0, 0, 0])
    .then((model) => {
      model.scale.set(0.5, 0.5, 0.5);
      modelRef.current = model;
  
      // Ajustar la posición de la cámara para que esté más alejada y más alta
      camera.position.set(5, 2, 10); // Elevar la cámara en el eje Y y alejarla en Z
  
      // Hacer que la cámara mire hacia el centro del modelo
      camera.lookAt(model.position);
  
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
  
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
  
      const animate = () => {
        frameId.current = requestAnimationFrame(animate);
        if (modelRef.current) {
          modelRef.current.rotation.y += 0.005; // Velocidad de rotación reducida
        }
        controls.update();
        renderer.render(scene, camera);
      };
  
      animate();
    }).catch(error => {
      console.error("Error loading the model:", error);
      setError(`Error loading the model: ${error.message}`);
    });

    const handleResize = () => {
      const width = currentRef.clientWidth;
      const height = currentRef.clientHeight;

      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(frameId.current);
      currentRef.removeChild(renderer.domElement);
      window.removeEventListener('resize', handleResize);
      scene.clear();
    };
  }, []);

  return (
    <div style={{ position: 'relative' }}>
      <div ref={ref} style={{ width: '100%', height: '1000px' }}></div>
      {error && <div style={{ color: 'red', position: 'absolute', top: 10, left: 10 }}>{error}</div>}
      {loadingStatus && <div style={{ position: 'absolute', top: 10, left: 10 }}>{loadingStatus}</div>}
      <div style={{ position: 'absolute', bottom: 10, left: 10, background: 'rgba(0,0,0,0.5)', color: 'white', padding: '10px', borderRadius: '5px' }}>
        <h3>Instrucciones:</h3>
        <ul>
          <li>The model rotates automatically</li>
          <li>Left click + drag: Rotate the view</li>
          <li>Right click + drag: Move the camera</li>
          <li>Mouse wheel: Zoom</li>
        </ul>

      </div>
    </div>
  );
}

export default CarViewer;
</file>

<file path="src/components/juegos/EnhancedCubes.js">
import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
import { RenderPixelatedPass } from './RenderPixelatedPass';

function EnhancedCubes() {
  const ref = useRef();
  const frameId = useRef();
  const mousePosition = useRef(new THREE.Vector2());

  useEffect(() => {
    const currentRef = ref.current;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, currentRef.clientWidth / currentRef.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    renderer.setSize(currentRef.clientWidth, currentRef.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    currentRef.appendChild(renderer.domElement);

    // Add subtle ambient light
    const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
    scene.add(ambientLight);

    // Add cool directional light from above
    const directionalLight = new THREE.DirectionalLight(0x4466ff, 0.5);
    directionalLight.position.set(0, 5, 0);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048; // Aumentamos la resolución de las sombras
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 1;
    directionalLight.shadow.camera.far = 10;
    directionalLight.shadow.camera.top = 5;
    directionalLight.shadow.camera.bottom = -5;
    directionalLight.shadow.camera.left = -5;
    directionalLight.shadow.camera.right = 5;
    scene.add(directionalLight);

    // Add intense warm spotlight
    const warmLight = new THREE.PointLight(0xffaa00, 2, 10);
    warmLight.position.set(0, 2, 0);
    warmLight.castShadow = true;
    warmLight.shadow.mapSize.width = 2048; // Aumentamos la resolución de las sombras
    warmLight.shadow.mapSize.height = 2048;
    scene.add(warmLight);

    // Add colorful rotating lights
    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff];
    const rotatingLights = colors.map((color, index) => {
      const light = new THREE.PointLight(color, 1, 5);
      light.position.set(
        Math.cos(index * Math.PI / 2) * 3,
        1,
        Math.sin(index * Math.PI / 2) * 3
      );
      scene.add(light);
      return light;
    });

    // Create a canvas to draw the text for the displacement map
    const canvasSize = 1024; // Aumentamos el tamaño del canvas
    const canvas = document.createElement('canvas');
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const context = canvas.getContext('2d');

    // Fill the canvas with black
    context.fillStyle = 'black';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Draw the text "Dante" in white with outline
    context.font = 'bold 400px Arial'; // Aumentamos el tamaño de la fuente
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // Draw stroke to enhance edges
    context.lineWidth = 20; // Aumentamos el grosor del borde
    context.strokeStyle = 'white';
    context.strokeText('Dante', canvas.width / 2, canvas.height / 2);
    context.fillText('Dante', canvas.width / 2, canvas.height / 2);

    // Create a displacement map from the canvas
    const displacementMap = new THREE.CanvasTexture(canvas);
    displacementMap.wrapS = displacementMap.wrapT = THREE.RepeatWrapping;

    // Add floor with displacement map
    const floorGeometry = new THREE.PlaneGeometry(10, 10, 512, 512); // Aumentamos los segmentos
    const floorMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      roughness: 0.8,
      metalness: 0.2,
      displacementMap: displacementMap,
      displacementScale: 0.5, // Aumentamos la escala de desplazamiento
      bumpMap: displacementMap,
      bumpScale: 0.5 // Aumentamos el bump scale
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.5;
    floor.receiveShadow = true;
    scene.add(floor);

    // Create two cubes
    const cubes = [];
    const cubeColors = [0x00ffff, 0xff00ff];
    for (let i = 0; i < 2; i++) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({
        color: cubeColors[i],
        metalness: 0.6,
        roughness: 0.4,
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(i * 2 - 1, 0.5, 0);
      cube.castShadow = true;
      cube.receiveShadow = true;
      scene.add(cube);
      cubes.push(cube);
    }

    camera.position.set(0, 4, 5);
    camera.lookAt(0, 0, 0);

    // Setup EffectComposer
    const composer = new EffectComposer(renderer);
    
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const renderPixelatedPass = new RenderPixelatedPass(512, scene, camera, { edgeStrength: 0.15 });
    composer.addPass(renderPixelatedPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(currentRef.clientWidth, currentRef.clientHeight),
      0.8,
      0.3,
      0.8
    );
    composer.addPass(bloomPass);

    const animate = (time) => {
      frameId.current = requestAnimationFrame(animate);

      cubes.forEach((cube, index) => {
        cube.rotation.x += 0.002;
        cube.rotation.y += 0.003;
        
        // Subtle movement based on mouse position
        cube.position.x = (index * 2 - 1) + mousePosition.current.x * 0.05;
        cube.position.z = mousePosition.current.y * 0.05;
        
        // Subtle pulsating effect
        const scale = 1 + 0.05 * Math.sin(time * 0.001 + index * Math.PI);
        cube.scale.set(scale, scale, scale);
      });

      // Animate directional light
      const lightAngle = time * 0.0005;
      directionalLight.position.x = Math.sin(lightAngle) * 3;
      directionalLight.position.z = Math.cos(lightAngle) * 3;
      directionalLight.position.y = 5 + Math.sin(lightAngle * 2) * 1;

      // Animate warm spotlight
      warmLight.position.x = Math.sin(lightAngle * 0.5) * 1.5;
      warmLight.position.z = Math.cos(lightAngle * 0.5) * 1.5;
      warmLight.intensity = 2 + 1.5 * Math.sin(time * 0.002);

      // Animate rotating lights
      rotatingLights.forEach((light, index) => {
        const angle = lightAngle * (index + 1) * 0.5;
        light.position.x = Math.cos(angle) * 3;
        light.position.z = Math.sin(angle) * 3;
        light.intensity = 1 + 0.5 * Math.sin(time * 0.003 + index);
      });

      composer.render();
    };

    animate(0);

    const handleResize = () => {
      const width = currentRef.clientWidth;
      const height = currentRef.clientHeight;
      renderer.setSize(width, height);
      composer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    const handleMouseMove = (event) => {
      mousePosition.current.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePosition.current.y = -(event.clientY / window.innerHeight) * 2 + 1;
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('mousemove', handleMouseMove);

    return () => {
      cancelAnimationFrame(frameId.current);
      currentRef.removeChild(renderer.domElement);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);

  return <div ref={ref} style={{ width: '100%', height: '400px' }}></div>;
}

export default EnhancedCubes;
</file>

<file path="src/components/juegos/futbol_1.js">
var createScene = function () {
    var scene = new BABYLON.Scene(engine);
    var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    // Función para limitar un valor entre un mínimo y un máximo
    function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    // Crear una cámara que seguirá al jugador
    var camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 10, -10), scene);
    camera.radius = 15;
    camera.heightOffset = 7;
    camera.rotationOffset = 180;
    camera.cameraAcceleration = 0.05;
    camera.maxCameraSpeed = 10;

    // Iluminación
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Crear el campo de fútbol
    var fieldWidth = 30;
    var fieldHeight = 20;
    var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: fieldWidth, height: fieldHeight}, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.1); // Color verde para el césped
    ground.material = groundMaterial;
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9, friction: 0.1 }, scene);

    // Función para crear texto plano en el campo
    var createFieldText = function(scene) {
        var textPlane = BABYLON.MeshBuilder.CreatePlane("textPlane", {width: fieldWidth * 0.8, height: fieldHeight * 0.4}, scene);
        textPlane.position.y = 0.02; // Ligeramente más elevado para evitar z-fighting
        textPlane.rotation.x = Math.PI / 2;

        var textureResolution = 4096; // Aumentamos la resolución para mayor detalle
        var textTexture = new BABYLON.DynamicTexture("dynamicTexture", textureResolution, scene);
        var textContext = textTexture.getContext();

        // Cargar fuente personalizada
        var fontFace = new FontFace('Pinyon Script', 'url(https://fonts.gstatic.com/s/pinyonscript/v11/6xKpdSJbL9-e9LuoeQiDRQR8WOXaPw.woff2)');
        fontFace.load().then(function(loadedFace) {
            document.fonts.add(loadedFace);
            drawText(0); // Dibujar texto inicial una vez que la fuente esté cargada
        });

        var drawText = function(offset) {
            textContext.clearRect(0, 0, textureResolution, textureResolution);
            textContext.font = "bold 700px 'Pinyon Script', cursive";
            textContext.textAlign = "center";
            textContext.textBaseline = "middle";
            
            // Sombra sutil
            textContext.shadowColor = "rgba(0, 50, 0, 0.3)";
            textContext.shadowBlur = 20;
            textContext.shadowOffsetX = 4;
            textContext.shadowOffsetY = 4;
            
            // Gradiente sutil
            var gradient = textContext.createLinearGradient(0, 0, 0, textureResolution);
            gradient.addColorStop(0, "rgba(100, 180, 100, 0.6)");
            gradient.addColorStop(1, "rgba(50, 150, 50, 0.6)");
            textContext.fillStyle = gradient;
            
            textContext.fillText("Dante", textureResolution / 2, textureResolution / 2 + offset);

            textTexture.update();
        };

        var textMaterial = new BABYLON.StandardMaterial("textMaterial", scene);
        textMaterial.diffuseTexture = textTexture;
        textMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        textMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        textMaterial.alpha = 0.5; // Ligera transparencia
        textMaterial.backFaceCulling = false;

        textPlane.material = textMaterial;

        // Animación sutil
        var animationOffset = 0;
        scene.registerBeforeRender(function() {
            animationOffset = Math.sin(performance.now() * 0.0005) * 10; // Movimiento suave
            drawText(animationOffset);
        });
    };

    // Llamar a la función para crear el texto
    createFieldText(scene);

    // Crear la pelota mejorada
    var ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 1, segments: 32}, scene);
    ball.position = new BABYLON.Vector3(0, 1, 0);
    var ballMaterial = new BABYLON.StandardMaterial("ballMat", scene);
    ballMaterial.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/soccerball.png", scene);
    ball.material = ballMaterial;
    ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9, friction: 0.1 }, scene);

    // Sistema de partículas mejorado
    var particleSystem = new BABYLON.ParticleSystem("particles", 500, scene);
    particleSystem.emitter = ball;
    particleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1);
    particleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);
    particleSystem.color1 = new BABYLON.Color4(1, 0.5, 0, 1);
    particleSystem.color2 = new BABYLON.Color4(1, 0, 0, 1);
    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0);
    particleSystem.minSize = 0.1;
    particleSystem.maxSize = 0.5;
    particleSystem.minLifeTime = 0.3;
    particleSystem.maxLifeTime = 1.5;
    particleSystem.emitRate = 100;
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
    particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);
    particleSystem.direction1 = new BABYLON.Vector3(-1, -1, -1);
    particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);
    particleSystem.minAngularSpeed = 0;
    particleSystem.maxAngularSpeed = Math.PI;
    particleSystem.minEmitPower = 1;
    particleSystem.maxEmitPower = 5;
    particleSystem.updateSpeed = 0.01;
    particleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
    particleSystem.start();

    // Crear el jugador (cubo)
    var player = BABYLON.MeshBuilder.CreateBox("player", {size: 1}, scene);
    player.position = new BABYLON.Vector3(-5, 0.5, 0);
    var playerMaterial = new BABYLON.StandardMaterial("playerMat", scene);
    playerMaterial.diffuseColor = new BABYLON.Color3(0.07, 0.26, 0.88);
    player.material = playerMaterial;
    player.physicsImpostor = new BABYLON.PhysicsImpostor(player, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 2, friction: 0.1, restitution: 0.1 }, scene);

    // Asignar el jugador como objetivo de la cámara
    camera.lockedTarget = player;

    // Crear porterías
    var createGoal = function(position) {
        var goal = BABYLON.MeshBuilder.CreateBox("goal", {width: 0.5, height: 3, depth: 5}, scene);
        goal.position = position;
        var goalMaterial = new BABYLON.StandardMaterial("goalMat", scene);
        goalMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        goal.material = goalMaterial;
        goal.physicsImpostor = new BABYLON.PhysicsImpostor(goal, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, scene);
        return goal;
    };

    var leftGoal = createGoal(new BABYLON.Vector3(-fieldWidth/2 + 0.25, 1.5, 0));
    var rightGoal = createGoal(new BABYLON.Vector3(fieldWidth/2 - 0.25, 1.5, 0));

    // Sistema de puntuación
    var score = {left: 0, right: 0};
    
    // Crear un AdvancedDynamicTexture para la interfaz de usuario
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    // Crear un rectángulo para el fondo del marcador
    var scoreBackground = new BABYLON.GUI.Rectangle();
    scoreBackground.width = "200px";
    scoreBackground.height = "40px";
    scoreBackground.cornerRadius = 20;
    scoreBackground.color = "White";
    scoreBackground.thickness = 2;
    scoreBackground.background = "Black";
    scoreBackground.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    scoreBackground.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
    scoreBackground.top = "10px";
    advancedTexture.addControl(scoreBackground);

    // Crear el texto del marcador
    var scoreText = new BABYLON.GUI.TextBlock();
    scoreText.text = "0 - 0";
    scoreText.color = "white";
    scoreText.fontSize = 24;
    scoreBackground.addControl(scoreText);

    // Función para actualizar el marcador
    var updateScore = function() {
        if (scoreText) {
            scoreText.text = score.left + " - " + score.right;
        }
    };

    // Función para reiniciar la pelota
    var resetBall = function() {
        if (ball && ball.physicsImpostor) {
            ball.position = new BABYLON.Vector3(0, 1, 0);
            ball.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
            ball.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
        }
    };

    // Detectar goles y mantener la pelota dentro del campo
    scene.onBeforeRenderObservable.add(() => {
        if (ball && ball.position) {
            // Gol en la portería izquierda
            if (ball.position.x < -fieldWidth/2 + 1.5 && Math.abs(ball.position.z) < 2.5 && ball.position.y < 3) {
                score.right++;
                updateScore();
                resetBall();
            } 
            // Gol en la portería derecha
            else if (ball.position.x > fieldWidth/2 - 1.5 && Math.abs(ball.position.z) < 2.5 && ball.position.y < 3) {
                score.left++;
                updateScore();
                resetBall();
            }

            // Mantener la pelota dentro del campo
            var ballRadius = 0.5;
            var halfFieldWidth = fieldWidth / 2 - ballRadius;
            var halfFieldHeight = fieldHeight / 2 - ballRadius;

            if (ball.physicsImpostor) {
                var velocity = ball.physicsImpostor.getLinearVelocity();
                var position = ball.position;

                if (Math.abs(position.x) > halfFieldWidth) {
                    position.x = Math.sign(position.x) * halfFieldWidth;
                    velocity.x *= -1;
                }
                
                if (Math.abs(position.z) > halfFieldHeight) {
                    position.z = Math.sign(position.z) * halfFieldHeight;
                    velocity.z *= -1;
                }

                ball.position = position;
                ball.physicsImpostor.setLinearVelocity(velocity);
            }

            // Ajustar la emisión de partículas según la velocidad de la pelota
            var speed = ball.physicsImpostor.getLinearVelocity().length();
            particleSystem.emitRate = Math.min(speed * 50, 500);
            particleSystem.minEmitPower = speed / 2;
            particleSystem.maxEmitPower = speed;
        }
    });

    // Control del jugador
    var moveSpeed = 10;
    var inputMap = {};

    scene.onKeyboardObservable.add((kbInfo) => {
        switch (kbInfo.type) {
            case BABYLON.KeyboardEventTypes.KEYDOWN:
                inputMap[kbInfo.event.key] = true;
                break;
            case BABYLON.KeyboardEventTypes.KEYUP:
                inputMap[kbInfo.event.key] = false;
                break;
        }
    });

   scene.onBeforeRenderObservable.add(() => {
        if (player && player.physicsImpostor) {
            var velocity = player.physicsImpostor.getLinearVelocity();
            var desiredVelocity = new BABYLON.Vector3(0, velocity.y, 0);

            if (inputMap["ArrowUp"] || inputMap["w"]) {
                desiredVelocity.z = moveSpeed;
            }
            if (inputMap["ArrowDown"] || inputMap["s"]) {
                desiredVelocity.z = -moveSpeed;
            }
            if (inputMap["ArrowLeft"] || inputMap["a"]) {
                desiredVelocity.x = -moveSpeed;
            }
            if (inputMap["ArrowRight"] || inputMap["d"]) {
                desiredVelocity.x = moveSpeed;
            }

            player.physicsImpostor.setLinearVelocity(desiredVelocity);
            player.rotationQuaternion = BABYLON.Quaternion.Identity();

            // Limitar la posición del jugador dentro del campo
            var halfFieldWidth = fieldWidth / 2 - 0.5;
            var halfFieldHeight = fieldHeight / 2 - 0.5;
            player.position.x = clamp(player.position.x, -halfFieldWidth, halfFieldWidth);
            player.position.z = clamp(player.position.z, -halfFieldHeight, halfFieldHeight);
        }
    });

    return scene;
};
</file>

<file path="src/components/juegos/HandInvadersGame.css">
/* Contenedor principal del juego */
.hand-invaders-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    gap: 20px;
}

/* Wrapper principal que contiene video y juego */
.hand-invaders-container .main-content-wrapper {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-content: center;
    flex-wrap: nowrap;
    gap: 20px;
    width: 100%;
    max-width: 940px;
}

/* Contenedor del video */
.hand-invaders-container .video-container {
    position: relative;
    width: 320px;
    max-width: 320px;
    flex-shrink: 0;
    padding-bottom: calc(320px * (240 / 320));
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    overflow: hidden;
}

/* Video de entrada */
.hand-invaders-container .input_video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* Canvas de overlay para el tracking */
.hand-invaders-container #overlayCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* Contenedor del juego */
.hand-invaders-container .container {
    position: relative;
    width: 600px;
    max-width: 600px;
    flex-shrink: 0;
    padding-bottom: calc(600px * (400 / 600));
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    overflow: hidden;
}

/* Área del juego */
.hand-invaders-container #game-area {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Canvas del juego */
.hand-invaders-container #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* Pantallas de carga/inicio/fin */
.hand-invaders-container #loading,
.hand-invaders-container #start-screen,
.hand-invaders-container #game-over-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    text-align: center;
    z-index: 10;
}

/* Botones */
.hand-invaders-container button {
    padding: 12px 24px;
    font-size: 1.2em;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s;
    margin-top: 20px;
}

.hand-invaders-container button:hover {
    background: #45a049;
}

/* Puntuación */
.hand-invaders-container .hand-invaders-score {
    font-size: 1.5em;
    color: white;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

/* Instrucciones */
.hand-invaders-container .hand-invaders-instructions {
    text-align: center;
    color: white;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    font-size: 1.1em;
    max-width: 600px;
    margin: 0 auto;
}

/* Media Query para Móvil */
@media (max-width: 960px) {
    .hand-invaders-container .main-content-wrapper {
        flex-wrap: wrap;
        flex-direction: column;
        align-items: center;
        gap: 30px;
    }

    .hand-invaders-container .video-container,
    .hand-invaders-container .container {
        flex-shrink: 1;
        width: 90%;
        max-width: 600px;
    }

    .hand-invaders-container .video-container {
        max-width: 320px;
    }

    .hand-invaders-container .hand-invaders-instructions {
        font-size: 1em;
        padding: 0 20px;
    }
}

/* Media Query para pantallas muy pequeñas */
@media (max-width: 480px) {
    .hand-invaders-container {
        padding: 10px;
    }

    .hand-invaders-container .video-container,
    .hand-invaders-container .container {
        width: 95%;
    }

    .hand-invaders-container button {
        padding: 10px 20px;
        font-size: 1em;
    }

    .hand-invaders-container .hand-invaders-score {
        font-size: 1.2em;
    }
}
</file>

<file path="src/components/juegos/HandInvadersGame.js">
import React, { useEffect, useRef } from 'react';
import './HandInvadersGame.css';
import { initGame } from './handInvadersLogic';

function HandInvadersGame() {
    // Refs for DOM elements the game logic needs
    const videoRef = useRef(null);
    const gameCanvasRef = useRef(null);
    const overlayCanvasRef = useRef(null);
    const loadingRef = useRef(null);
    const startScreenRef = useRef(null);
    const gameOverScreenRef = useRef(null);
    const scoreRef = useRef(null);
    const finalScoreRef = useRef(null);
    const startButtonRef = useRef(null);
    const restartButtonRef = useRef(null);

    // Ref to store cleanup function returned by initGame
    const cleanupFuncRef = useRef(null);

    useEffect(() => {
        // Check if MediaPipe is loaded (assuming global loading)
        if (window.Hands && window.Camera && window.drawConnectors) {
            const elements = {
                videoElement: videoRef.current,
                gameCanvasElement: gameCanvasRef.current,
                overlayCanvasElement: overlayCanvasRef.current,
                loadingElement: loadingRef.current,
                startScreenElement: startScreenRef.current,
                gameOverScreenElement: gameOverScreenRef.current,
                scoreElement: scoreRef.current,
                finalScoreElement: finalScoreRef.current,
                startButton: startButtonRef.current,
                restartButton: restartButtonRef.current,
            };

            // Initialize the game logic, passing the elements
            // Store the returned cleanup function
            cleanupFuncRef.current = initGame(elements);

        } else {
            console.error("MediaPipe scripts not loaded yet!");
            if (loadingRef.current) {
                loadingRef.current.textContent = "Error: Required scripts not loaded.";
                loadingRef.current.style.display = 'flex';
            }
        }

        // Cleanup function when component unmounts
        return () => {
            console.log("Cleaning up HandInvadersGame...");
            if (cleanupFuncRef.current) {
                cleanupFuncRef.current();
            }
        };
    }, []); // Empty dependency array ensures this runs only once on mount

    return (
        <div className="hand-invaders-container">
            {/* Game/Video Row */}
            <div className="main-content-wrapper">
                {/* Video and Overlay Area (Now First) */}
                <div className="video-container">
                    <video ref={videoRef} id="webcam" className="input_video" autoPlay playsInline></video>
                    <canvas ref={overlayCanvasRef} id="overlayCanvas"></canvas>
                </div>

                {/* Game Area (Now Second) */}
                <div className="container">
                    <div id="game-area">
                        <canvas ref={gameCanvasRef} id="gameCanvas" width="600" height="400"></canvas>
                        <div ref={loadingRef} id="loading">Loading hand model and camera...</div>
                        <div ref={startScreenRef} id="start-screen" style={{ display: 'none' }}>
                            <h2>Ready to Play</h2>
                            <button ref={startButtonRef} id="startButton">Start Game</button>
                        </div>
                        <div ref={gameOverScreenRef} id="game-over-screen" style={{ display: 'none' }}>
                            <h2>Game Over!</h2>
                            <p>Final Score: <span ref={finalScoreRef} id="final-score">0</span></p>
                            <button ref={restartButtonRef} id="restartButton">Play Again</button>
                        </div>
                    </div>
                </div>
            </div>

            {/* Score Display */}
            <div className="info hand-invaders-score">
                Score: <span ref={scoreRef} id="score">0</span>
            </div>
            {/* Instructions */}
            <div className="hand-invaders-instructions">
                <p>Use your right hand. Move horizontally to move. Pinch to shoot.</p>
            </div>
        </div>
    );
}

export default HandInvadersGame;
</file>

<file path="src/components/juegos/handInvadersLogic.js">
// Store variables that need to persist across calls within this module's scope
let hands, camera, animationFrameId;
let score, gameRunning, gameOver, player, bullets, enemies, powerups, shootInterval, handLandmarks;
let stars, backgroundGradient;
let playerImageLoaded = false, enemyImageLoaded = false;
let playerImage = new Image(), enemyImage = new Image();
let rapidFireFlash = false;

// Keep constants outside the init function
const gameCanvasWidth = 600;
const gameCanvasHeight = 400;
const overlayCanvasWidth = 320;
const overlayCanvasHeight = 240;

// --- Game Settings (Constants) ---
const bulletSpeed = 7;
const bulletWidth = 5;
const bulletHeight = 10;
const bulletColor = 'yellow';

const enemyAspectRatio = 35 / 25;
const enemyWidth = 35;
const enemyHeight = enemyWidth / enemyAspectRatio;
const enemyRows = 4;
const enemyCols = 8;
const enemySpacing = 15;
const enemyInitialY = 30;
const enemyInitialX = (gameCanvasWidth - (enemyCols * (enemyWidth + enemySpacing))) / 2;
let enemySpeed = 1;
let enemyDirection = 1;
let enemyDropDistance = 15;

const POWERUP_TYPES = { RAPID_FIRE: 'rapid_fire', SHIELD: 'shield' };
const powerupSize = 20;
const powerupSpeed = 2;
const powerupSpawnChance = 0.1;
const rapidFireDuration = 7000;
const rapidFireInterval = 5;
const originalShootInterval = 15;

const NUM_STARS = 150;
const STAR_SCROLL_SPEED = 0.3;

// Player default structure
let defaultPlayer = {
    x: gameCanvasWidth / 2 - 30,
    y: gameCanvasHeight - 60,
    width: 60,
    height: 55,
    speed: 15,
    dx: 0,
    smoothingFactor: 0.3,
    shieldActive: false,
    rapidFireActive: false,
    rapidFireTimeoutId: null,
    originalShootInterval: originalShootInterval
};

// SVG strings for player and enemy
const playerSvgString = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 55">
  <defs>
    <linearGradient id="bodyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#30FFFF; stop-opacity:1" />
      <stop offset="100%" style="stop-color:#00A0A0; stop-opacity:1" />
    </linearGradient>
    <linearGradient id="engineGlow" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#FFFF80;" />
      <stop offset="100%" style="stop-color:#FF8000;" />
    </linearGradient>
  </defs>
  <path d="M 25 53 Q 30 58 35 53 L 32 48 L 28 48 Z"
        fill="url(#engineGlow)" stroke="orange" stroke-width="0.5"/>
  <path d="M 30 0 L 10 25 C 5 30, 5 35, 15 40 L 25 50 L 35 50 L 45 40 C 55 35, 55 30, 50 25 Z"
        fill="url(#bodyGradient)" stroke="#FFFFFF" stroke-width="1.5" stroke-linejoin="round"/>
  <path d="M 30 5 L 22 20 L 38 20 Z" fill="#E0FFFF" stroke="white" stroke-width="1"/>
  <line x1="30" y1="5" x2="30" y2="18" stroke="#A0FFFF" stroke-width="1" />
  <circle cx="12" cy="28" r="1.5" fill="white"/>
  <circle cx="48" cy="28" r="1.5" fill="white"/>
</svg>`;

const enemySvgString = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 35 25">
  <defs>
    <linearGradient id="enemyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#E040E0; stop-opacity:1" />
      <stop offset="100%" style="stop-color:#800080; stop-opacity:1" />
    </linearGradient>
  </defs>
  <path d="M 5 5 L 10 15 L 15 12 L 20 12 L 25 15 L 30 5 L 25 8 L 20 5 L 15 5 L 10 8 Z"
        fill="url(#enemyGradient)" stroke="#FFFFFF" stroke-width="1" />
  <rect x="12" y="15" width="3" height="4" fill="yellow" />
  <rect x="20" y="15" width="3" height="4" fill="yellow" />
  <line x1="8" y1="5" x2="5" y2="0" stroke="white" stroke-width="0.5" />
  <line x1="27" y1="5" x2="30" y2="0" stroke="white" stroke-width="0.5" />
</svg>`;

// --- Exported Initialization Function ---
export function initGame(elements) {
    console.log("Initializing Hand Invaders Logic...");

    // Destructure passed elements
    const {
        videoElement,
        gameCanvasElement,
        overlayCanvasElement,
        loadingElement,
        startScreenElement,
        gameOverScreenElement,
        scoreElement,
        finalScoreElement,
        startButton,
        restartButton
    } = elements;

    // Get contexts
    const canvasCtx = gameCanvasElement.getContext('2d');
    const overlayCtx = overlayCanvasElement.getContext('2d');
    overlayCanvasElement.width = overlayCanvasWidth;
    overlayCanvasElement.height = overlayCanvasHeight;

    // Reset state variables
    score = 0;
    gameRunning = false;
    gameOver = false;
    player = { ...defaultPlayer };
    bullets = [];
    enemies = [];
    powerups = [];
    shootInterval = player.originalShootInterval;
    handLandmarks = null;
    stars = [];
    backgroundGradient = null;
    animationFrameId = null;
    playerImageLoaded = false;
    enemyImageLoaded = false;

    if (player.rapidFireTimeoutId) {
        clearTimeout(player.rapidFireTimeoutId);
        player.rapidFireTimeoutId = null;
    }

    // Load SVGs
    const encodedPlayerSvg = encodeURIComponent(playerSvgString);
    playerImage.src = 'data:image/svg+xml;charset=utf-8,' + encodedPlayerSvg;
    playerImage.onload = () => {
        playerImageLoaded = true;
        console.log("Player SVG loaded (Logic).");
        const aspectRatio = 60 / 55;
        const desiredHeight = 40;
        player.height = desiredHeight;
        player.width = desiredHeight * aspectRatio;
        player.x = gameCanvasWidth / 2 - player.width / 2;
        player.y = gameCanvasHeight - player.height - 10;
    };
    playerImage.onerror = (err) => { console.error("Error loading player SVG (Logic):", err); };

    const encodedEnemySvg = encodeURIComponent(enemySvgString);
    enemyImage.src = 'data:image/svg+xml;charset=utf-8,' + encodedEnemySvg;
    enemyImage.onload = () => {
        enemyImageLoaded = true;
        console.log("Enemy SVG loaded (Logic).");
    };
    enemyImage.onerror = (err) => { console.error("Error loading enemy SVG (Logic):", err); };

    // --- MediaPipe Setup ---
    const drawingUtils = window;
    hands = new window.Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onHandResults);

    // --- Camera Setup ---
    camera = new window.Camera(videoElement, {
        onFrame: async () => {
            if (videoElement.readyState >= 2) {
                if (overlayCanvasElement.width !== videoElement.videoWidth) {
                    overlayCanvasElement.width = videoElement.videoWidth;
                }
                if (overlayCanvasElement.height !== videoElement.videoHeight) {
                    overlayCanvasElement.height = videoElement.videoHeight;
                }
                await hands.send({ image: videoElement });
            }
        },
        width: 640,
        height: 480
    });

    // --- Game Logic Functions ---
    function initBackground() {
        stars = [];
        for (let i = 0; i < NUM_STARS; i++) {
            stars.push({
                x: Math.random() * gameCanvasWidth,
                y: Math.random() * gameCanvasHeight,
                radius: Math.random() * 1.5 + 0.5,
                alpha: Math.random() * 0.5 + 0.5
            });
        }

        const gradientCenterX = gameCanvasWidth * 0.3;
        const gradientCenterY = gameCanvasHeight * 0.4;
        const gradientOuterRadius = gameCanvasWidth * 0.6;
        backgroundGradient = canvasCtx.createRadialGradient(
            gradientCenterX,
            gradientCenterY,
            0,
            gradientCenterX,
            gradientCenterY,
            gradientOuterRadius
        );
        backgroundGradient.addColorStop(0, 'rgba(40, 0, 80, 0.4)');
        backgroundGradient.addColorStop(0.6, 'rgba(20, 0, 40, 0.1)');
        backgroundGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        console.log("Background initialized (Logic).");
    }

    function updateBackground() {
        stars.forEach(star => {
            star.y += STAR_SCROLL_SPEED;
            if (star.y > gameCanvasHeight) {
                star.y = 0;
                star.x = Math.random() * gameCanvasWidth;
            }
            if (Math.random() < 0.005) {
                star.alpha = Math.random() * 0.5 + 0.5;
            }
        });
    }

    function drawBackground() {
        canvasCtx.fillStyle = '#000010';
        canvasCtx.fillRect(0, 0, gameCanvasWidth, gameCanvasHeight);
        if (backgroundGradient) {
            canvasCtx.fillStyle = backgroundGradient;
            canvasCtx.fillRect(0, 0, gameCanvasWidth, gameCanvasHeight);
        }
        stars.forEach(star => {
            canvasCtx.beginPath();
            canvasCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            canvasCtx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
            canvasCtx.fill();
        });
    }

    function initEnemies() {
        enemies = [];
        for (let row = 0; row < enemyRows; row++) {
            for (let col = 0; col < enemyCols; col++) {
                enemies.push({
                    x: enemyInitialX + col * (enemyWidth + enemySpacing) + (enemySpacing / 2),
                    y: enemyInitialY + row * (enemyHeight + enemySpacing),
                    width: enemyWidth,
                    height: enemyHeight,
                    alive: true
                });
            }
        }
    }

    function drawRect(ctx, x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
    }

    function drawPlayer() {
        if (player.shieldActive) {
            canvasCtx.fillStyle = 'rgba(0, 150, 255, 0.3)';
            canvasCtx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;
            const radius = Math.max(player.width, player.height) / 1.8;
            canvasCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            canvasCtx.fill();
            canvasCtx.stroke();
        }
        if (playerImageLoaded) {
            canvasCtx.drawImage(playerImage, player.x, player.y, player.width, player.height);
        } else {
            drawRect(canvasCtx, player.x, player.y, player.width, player.height, 'darkcyan');
        }
    }

    function drawBullets() {
        bullets.forEach(b => drawRect(canvasCtx, b.x, b.y, bulletWidth, bulletHeight, bulletColor));
    }

    function drawEnemies() {
        enemies.forEach(enemy => {
            if (enemy.alive) {
                if (enemyImageLoaded) {
                    canvasCtx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
                } else {
                    drawRect(canvasCtx, enemy.x, enemy.y, enemy.width, enemy.height, '#800080');
                }
            }
        });
    }

    function drawPowerups() {
        if (Math.floor(Date.now() / 200) % 2 === 0) {
            rapidFireFlash = true;
        } else {
            rapidFireFlash = false;
        }
        powerups.forEach(p => {
            canvasCtx.font = "bold 14px sans-serif";
            canvasCtx.textAlign = "center";
            canvasCtx.textBaseline = "middle";
            const centerX = p.x + p.width / 2;
            const centerY = p.y + p.height / 2;
            if (p.type === POWERUP_TYPES.RAPID_FIRE) {
                canvasCtx.fillStyle = rapidFireFlash ? 'orange' : 'yellow';
                drawRect(canvasCtx, p.x, p.y, p.width, p.height, canvasCtx.fillStyle);
                canvasCtx.fillStyle = 'black';
                canvasCtx.fillText('R', centerX, centerY);
            } else if (p.type === POWERUP_TYPES.SHIELD) {
                canvasCtx.fillStyle = 'blue';
                canvasCtx.strokeStyle = 'white';
                canvasCtx.lineWidth = 1;
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, p.width / 2, 0, Math.PI * 2);
                canvasCtx.fill();
                canvasCtx.stroke();
                canvasCtx.fillStyle = 'white';
                canvasCtx.fillText('S', centerX, centerY);
            }
        });
    }

    function updateBullets() {
        bullets = bullets.filter(b => b.y > 0);
        bullets.forEach(b => { b.y -= bulletSpeed; });
    }

    function updateEnemies() {
        let moveDown = false;
        let hitEdge = false;
        enemies.forEach(enemy => {
            if (!enemy.alive) return;
            enemy.x += enemySpeed * enemyDirection;
            if (enemy.x + enemy.width > gameCanvasWidth || enemy.x < 0) {
                hitEdge = true;
            }
            if (enemy.y + enemy.height >= player.y &&
                enemy.x < player.x + player.width &&
                enemy.x + enemy.width > player.x) {
                handlePlayerHit();
            }
        });
        if (hitEdge) {
            enemyDirection *= -1;
            moveDown = true;
        }
        if (moveDown) {
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    enemy.y += enemyDropDistance;
                    if (enemy.y + enemy.height >= gameCanvasHeight) {
                        setGameOver("Invaders reached the bottom!");
                    }
                }
            });
        }
    }

    function updatePowerups() {
        powerups = powerups.filter(p => p.y < gameCanvasHeight);
        powerups.forEach(p => { p.y += powerupSpeed; });
    }

    function checkCollisions() {
        bullets.forEach((bullet, bulletIndex) => {
            enemies.forEach((enemy) => {
                if (enemy.alive &&
                    bullet.x < enemy.x + enemy.width &&
                    bullet.x + bullet.width > enemy.x &&
                    bullet.y < enemy.y + enemy.height &&
                    bullet.y + bullet.height > enemy.y) {
                    enemy.alive = false;
                    bullets.splice(bulletIndex, 1);
                    score += 10;
                    scoreElement.textContent = score;
                    if (Math.random() < powerupSpawnChance) {
                        spawnPowerup(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    }
                    if (enemies.every(e => !e.alive)) {
                        resetGame();
                    }
                    return;
                }
            });
        });
        powerups.forEach((powerup, index) => {
            if (player.x < powerup.x + powerup.width &&
                player.x + player.width > powerup.x &&
                player.y < powerup.y + powerup.height &&
                player.y + player.height > powerup.y) {
                activatePowerup(powerup.type);
                powerups.splice(index, 1);
            }
        });
    }

    function handlePlayerHit() {
        if (player.shieldActive) {
            player.shieldActive = false;
            console.log("Shield broken!");
            enemies.forEach(enemy => {
                if (enemy.alive &&
                    enemy.y + enemy.height >= player.y &&
                    enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x) {
                    enemy.alive = false;
                    score += 5;
                    scoreElement.textContent = score;
                }
            });
        } else {
            setGameOver("Game Over!");
        }
    }

    let shootCooldown = 0;

    function shoot() {
        if (shootCooldown <= 0) {
            bullets.push({
                x: player.x + player.width / 2 - bulletWidth / 2,
                y: player.y,
                width: bulletWidth,
                height: bulletHeight,
                color: bulletColor
            });
            shootCooldown = shootInterval;
        }
    }

    function spawnPowerup(x, y) {
        const type = Math.random() < 0.5 ? POWERUP_TYPES.RAPID_FIRE : POWERUP_TYPES.SHIELD;
        powerups.push({
            x: x - powerupSize / 2,
            y: y - powerupSize / 2,
            width: powerupSize,
            height: powerupSize,
            type: type,
            speed: powerupSpeed
        });
        console.log("Spawned powerup:", type);
    }

    function activatePowerup(type) {
        console.log("Activated powerup:", type);
        if (type === POWERUP_TYPES.SHIELD) {
            player.shieldActive = true;
        } else if (type === POWERUP_TYPES.RAPID_FIRE) {
            if (player.rapidFireTimeoutId) {
                clearTimeout(player.rapidFireTimeoutId);
            }
            player.rapidFireActive = true;
            shootInterval = rapidFireInterval;
            player.rapidFireTimeoutId = setTimeout(() => {
                player.rapidFireActive = false;
                shootInterval = player.originalShootInterval;
                player.rapidFireTimeoutId = null;
                console.log("Rapid fire ended.");
            }, rapidFireDuration);
        }
    }

    function updatePlayerPosition(handX) {
        const targetX = (1 - handX) * gameCanvasWidth - player.width / 2;
        player.x += (targetX - player.x) * player.smoothingFactor;
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > gameCanvasWidth) player.x = gameCanvasWidth - player.width;
    }

    function checkShootGesture(landmarks) {
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        if (!thumbTip || !indexTip) return false;
        const distance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) +
            Math.pow(thumbTip.y - indexTip.y, 2)
        );
        const pinchThreshold = 0.05;
        return distance < pinchThreshold;
    }

    function onHandResults(results) {
        overlayCtx.clearRect(0, 0, overlayCanvasElement.width, overlayCanvasElement.height);
        handLandmarks = null;
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handLandmarks = results.multiHandLandmarks[0];
            for (const landmarks of results.multiHandLandmarks) {
                drawingUtils.drawConnectors(overlayCtx, landmarks, window.HAND_CONNECTIONS, {
                    color: '#00FF00',
                    lineWidth: 5
                });
                drawingUtils.drawLandmarks(overlayCtx, landmarks, {
                    color: '#FF0000',
                    lineWidth: 2,
                    radius: 5
                });
            }
            if (gameRunning && !gameOver && handLandmarks) {
                const wrist = handLandmarks[0];
                if (wrist) {
                    updatePlayerPosition(wrist.x);
                }
                if (checkShootGesture(handLandmarks)) {
                    shoot();
                }
            }
        }
    }

    function setGameOver(message = "Game Over!") {
        gameRunning = false;
        gameOver = true;
        finalScoreElement.textContent = score;
        gameOverScreenElement.querySelector('h2').textContent = message;
        gameOverScreenElement.style.display = 'flex';
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    }

    function gameLoop() {
        if (!gameRunning || gameOver) return;
        if (shootCooldown > 0) shootCooldown--;
        updateBackground();
        updateBullets();
        updateEnemies();
        updatePowerups();
        checkCollisions();
        drawBackground();
        drawEnemies();
        drawPowerups();
        drawPlayer();
        drawBullets();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        if (player.rapidFireTimeoutId) {
            clearTimeout(player.rapidFireTimeoutId);
            player.rapidFireTimeoutId = null;
        }

        score = 0;
        scoreElement.textContent = score;
        player = { ...defaultPlayer };
        if (playerImageLoaded) {
            const aspectRatio = 60 / 55;
            const desiredHeight = 40;
            player.height = desiredHeight;
            player.width = desiredHeight * aspectRatio;
        }
        player.x = gameCanvasWidth / 2 - player.width / 2;
        player.y = gameCanvasHeight - player.height - 10;

        bullets = [];
        powerups = [];
        enemyDirection = 1;
        enemySpeed = 1;
        initEnemies();
        initBackground();

        gameOver = false;
        gameRunning = true;
        gameOverScreenElement.style.display = 'none';
        loadingElement.style.display = 'none';
        startScreenElement.style.display = 'none';

        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        gameLoop();
    }

    // --- Event Listeners ---
    const startGameHandler = () => {
        resetGame();
        startScreenElement.style.display = 'none';
    };

    const restartGameHandler = () => {
        resetGame();
        gameOverScreenElement.style.display = 'none';
    };

    startButton.addEventListener('click', startGameHandler);
    restartButton.addEventListener('click', restartGameHandler);

    // --- Start Camera & Initial Setup ---
    camera.start()
        .then(() => {
            console.log("Camera started (Logic). MediaPipe ready.");
            loadingElement.style.display = 'none';
            startScreenElement.style.display = 'flex';
        })
        .catch(err => {
            console.error("Error starting camera (Logic):", err);
            loadingElement.textContent = "Error accessing camera. Check permissions.";
            loadingElement.style.display = 'flex';
            startScreenElement.style.display = 'none';
        });

    // --- Return cleanup function ---
    return () => {
        console.log("Running cleanup for Hand Invaders Logic...");
        gameRunning = false;
        gameOver = true;

        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        if (camera) {
            camera.stop();
            const stream = videoElement.srcObject;
            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            camera = null;
            console.log("Camera stopped.");
        } else {
            console.log("Camera object not found for cleanup.");
        }

        if (hands) {
            hands.close();
            hands = null;
            console.log("MediaPipe Hands closed.");
        }

        if (player && player.rapidFireTimeoutId) {
            clearTimeout(player.rapidFireTimeoutId);
            player.rapidFireTimeoutId = null;
        }

        startButton.removeEventListener('click', startGameHandler);
        restartButton.removeEventListener('click', restartGameHandler);
        console.log("Event listeners removed.");

        if (canvasCtx) canvasCtx.clearRect(0, 0, gameCanvasWidth, gameCanvasHeight);
        if (overlayCtx) overlayCtx.clearRect(0, 0, overlayCanvasWidth, overlayCanvasHeight);

        player = null;
        enemies = null;
        bullets = null;
        powerups = null;
        stars = null;
        console.log("Hand Invaders Logic cleanup complete.");
    };
}
</file>

<file path="src/components/juegos/ModelViewer.js">
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

function ModelViewer() {
  const ref = useRef();
  const frameId = useRef();
  const modelRef = useRef();
  const [error, setError] = useState(null);
  const [loadingStatus, setLoadingStatus] = useState('');

  useEffect(() => {
    const currentRef = ref.current;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc);
    const camera = new THREE.PerspectiveCamera(75, currentRef.clientWidth / currentRef.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(currentRef.clientWidth, currentRef.clientHeight);
    currentRef.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;

    const loader = new GLTFLoader();

    // Función para cargar un modelo
    const loadModel = (url, position) => {
      setLoadingStatus(`Loading model...`);
      return new Promise((resolve, reject) => {
        loader.load(
          url,
          (gltf) => {
            const model = gltf.scene;
            model.position.set(...position);
            scene.add(model);
            setLoadingStatus(`Model loaded successfully`);
            resolve(model);
          },
          undefined,
          (error) => {
            console.error(`Error loading model:`, error);
            setError(`Error loading model: ${error.message}`);
            reject(error);
          }
        );
      });
    };

    // Cargar solo el modelo shaded
    loadModel('/base_basic_shaded.glb', [0, 0, 0])
      .then((model) => {
        model.scale.set(0.5, 0.5, 0.5);
        modelRef.current = model;

        // Acercar la cámara al modelo
        camera.position.z = 2;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const animate = () => {
          frameId.current = requestAnimationFrame(animate);
          if (modelRef.current) {
            modelRef.current.rotation.y += 0.005; // Velocidad de rotación reducida
          }
          controls.update();
          renderer.render(scene, camera);
        };

        animate();
      }).catch(error => {
        console.error("Error loading the model:", error);
        setError(`Error loading the model: ${error.message}`);
      });

    const handleResize = () => {
      const width = currentRef.clientWidth;
      const height = currentRef.clientHeight;

      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(frameId.current);
      currentRef.removeChild(renderer.domElement);
      window.removeEventListener('resize', handleResize);
      scene.clear();
    };
  }, []);

  return (
    <div style={{ position: 'relative' }}>
      <div ref={ref} style={{ width: '100%', height: '1000px' }}></div>
      {error && <div style={{ color: 'red', position: 'absolute', top: 10, left: 10 }}>{error}</div>}
      {loadingStatus && <div style={{ position: 'absolute', top: 10, left: 10 }}>{loadingStatus}</div>}
      <div style={{ position: 'absolute', bottom: 10, left: 10, background: 'rgba(0,0,0,0.5)', color: 'white', padding: '10px', borderRadius: '5px' }}>
        <h3>Instrucciones:</h3>
        <ul>
          <li>The model rotates automatically</li>
          <li>Left click + drag: Rotate the view</li>
          <li>Right click + drag: Move the camera</li>
          <li>Mouse wheel: Zoom</li>
        </ul>

      </div>
    </div>
  );
}

export default ModelViewer;
</file>

<file path="src/components/juegos/Pass.js">
import {
	BufferGeometry,
	Float32BufferAttribute,
	OrthographicCamera,
	Mesh
} from 'three';

class Pass {

	constructor() {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	}

	setSize( /* width, height */ ) {}

	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry = new BufferGeometry();
_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

class FullScreenQuad {

	constructor( material ) {

		this._mesh = new Mesh( _geometry, material );

	}

	dispose() {

		this._mesh.geometry.dispose();

	}

	render( renderer ) {

		renderer.render( this._mesh, _camera );

	}

	get material() {

		return this._mesh.material;

	}

	set material( value ) {

		this._mesh.material = value;

	}

}

export { Pass, FullScreenQuad };
</file>

<file path="src/components/juegos/PixelatePass.js">
import * as THREE from 'three';
import { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';

export class PixelatePass extends Pass {
  constructor(resolution) {
    super();
    this.resolution = new THREE.Vector2(resolution, resolution);
    this.fsQuad = new FullScreenQuad(this.createMaterial());
  }

  render(renderer, writeBuffer, readBuffer) {
    const uniforms = this.fsQuad.material.uniforms;
    uniforms.tDiffuse.value = readBuffer.texture;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }

  createMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        resolution: {
          value: new THREE.Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec4 resolution;
        varying vec2 vUv;
        void main() {
          vec2 uv = vUv;
          vec2 pixelatedUV = floor(uv * resolution.xy) / resolution.xy;
          gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
      `
    });
  }
}
</file>

<file path="src/components/juegos/PongGame.js">
import React, { useRef, useEffect, useState } from 'react';

const PongGame = () => {
    const canvasRef = useRef(null);
    const [playerScore, setPlayerScore] = useState(0);
    const [computerScore, setComputerScore] = useState(0);
    const [gameState, setGameState] = useState('name');
    const [difficulty, setDifficulty] = useState('medium');
    const [playerName, setPlayerName] = useState('');
    const [inputError, setInputError] = useState('');

    const paddleHeight = 100;
    const paddleWidth = 15;
    const ballRadius = 10;

    const difficultySettings = {
        easy: { paddleSpeed: 1.5, ballSpeed: 3, computerAccuracy: 0.7 },
        medium: { paddleSpeed: 2, ballSpeed: 4, computerAccuracy: 0.8 },
        hard: { paddleSpeed: 2.5, ballSpeed: 5, computerAccuracy: 0.9 }
    };

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationFrameId;
        let playerPaddleY = canvas.height / 2 - paddleHeight / 2;
        let computerPaddleY = canvas.height / 2 - paddleHeight / 2;
        let ball = { x: canvas.width / 2, y: canvas.height / 2, dx: difficultySettings[difficulty].ballSpeed, dy: difficultySettings[difficulty].ballSpeed };

        const resetBall = () => {
            ball = { 
                x: canvas.width / 2, 
                y: canvas.height / 2, 
                dx: (Math.random() > 0.5 ? 1 : -1) * difficultySettings[difficulty].ballSpeed, 
                dy: (Math.random() > 0.5 ? 1 : -1) * difficultySettings[difficulty].ballSpeed 
            };
        };

        const update = () => {
            if (gameState !== 'playing') return;

            ball.x += ball.dx;
            ball.y += ball.dy;

            if (ball.y + ball.dy > canvas.height - ballRadius || ball.y + ball.dy < ballRadius) {
                ball.dy = -ball.dy;
            }

            if (
                (ball.dx < 0 && ball.x - ballRadius <= paddleWidth && ball.y >= playerPaddleY && ball.y <= playerPaddleY + paddleHeight) ||
                (ball.dx > 0 && ball.x + ballRadius >= canvas.width - paddleWidth && ball.y >= computerPaddleY && ball.y <= computerPaddleY + paddleHeight)
            ) {
                ball.dx = -ball.dx * 1.05;
                const paddleCenter = ball.dx < 0 ? playerPaddleY + paddleHeight / 2 : computerPaddleY + paddleHeight / 2;
                ball.dy = (ball.y - paddleCenter) * 0.2;
            }

            if (ball.x + ballRadius > canvas.width) {
                setPlayerScore(prevScore => {
                    const newScore = prevScore + 1;
                    if (newScore === 10) setGameState('gameOver');
                    return newScore;
                });
                resetBall();
            } else if (ball.x - ballRadius < 0) {
                setComputerScore(prevScore => {
                    const newScore = prevScore + 1;
                    if (newScore === 10) setGameState('gameOver');
                    return newScore;
                });
                resetBall();
            }

            const computerIdealY = ball.y - paddleHeight / 2;
            if (Math.random() < difficultySettings[difficulty].computerAccuracy) {
                computerPaddleY += (computerIdealY - computerPaddleY) * 0.1;
            }
            computerPaddleY = Math.max(0, Math.min(canvas.height - paddleHeight, computerPaddleY));
        };

        const drawBackground = () => {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 200px Arial';
            ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('DANTE', canvas.width / 2, canvas.height / 2);
        };

        const draw = () => {
            drawBackground();

            ctx.strokeStyle = '#FFFFFF';
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, playerPaddleY, paddleWidth, paddleHeight);
            ctx.fillRect(canvas.width - paddleWidth, computerPaddleY, paddleWidth, paddleHeight);

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.font = '32px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${playerName}: ${playerScore}`, 20, 50);
            ctx.textAlign = 'right';
            ctx.fillText(`AI: ${computerScore}`, canvas.width - 20, 50);

            if (gameState !== 'playing') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                if (gameState === 'start') {
                    ctx.fillText('Press SPACE to start', canvas.width / 2, canvas.height / 2);
                } else if (gameState === 'paused') {
                    ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
                } else if (gameState === 'gameOver') {
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.font = '32px Arial';
                    const winner = playerScore > computerScore ? playerName : 'AI';
                    ctx.fillText(`${winner} wins!`, canvas.width / 2, canvas.height / 2 + 50);
                    ctx.fillText('Press R to restart', canvas.width / 2, canvas.height / 2 + 100);
                } else if (gameState === 'instructions') {
                    ctx.font = '24px Arial';
                    ctx.fillText('Instructions:', canvas.width / 2, 100);
                    ctx.fillText('Use ↑↓ or W/S to move paddle', canvas.width / 2, 150);
                    ctx.fillText('SPACE to start/pause', canvas.width / 2, 200);
                    ctx.fillText('R to reset', canvas.width / 2, 250);
                    ctx.fillText('1-2-3 to change difficulty', canvas.width / 2, 300);
                    ctx.fillText('Press SPACE to continue', canvas.width / 2, 350);
                }
            }
        };

        const gameLoop = () => {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        };

        const handleKeyDown = (e) => {
            if (gameState === 'instructions') {
                if (e.code === 'Space') {
                    setGameState('start');
                }
            } else if (gameState === 'start' || gameState === 'playing' || gameState === 'paused') {
                if (e.code === 'Space') {
                    setGameState(prevState => prevState === 'playing' ? 'paused' : 'playing');
                }
                if (e.code === 'KeyR') {
                    setPlayerScore(0);
                    setComputerScore(0);
                    setGameState('start');
                    resetBall();
                }
                if (['Digit1', 'Digit2', 'Digit3'].includes(e.code)) {
                    setDifficulty(e.code === 'Digit1' ? 'easy' : e.code === 'Digit2' ? 'medium' : 'hard');
                    setGameState('start');
                    resetBall();
                }
                if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                    playerPaddleY = Math.max(0, playerPaddleY - 20);
                }
                if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                    playerPaddleY = Math.min(canvas.height - paddleHeight, playerPaddleY + 20);
                }
            }
        };

        document.addEventListener('keydown', handleKeyDown);
        gameLoop();

        return () => {
            cancelAnimationFrame(animationFrameId);
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [difficulty, gameState, playerScore, computerScore, playerName]);

    const handleNameSubmit = (e) => {
        e.preventDefault();
        if (playerName.trim()) {
            setInputError('');
            setGameState('instructions');
        } else {
            setInputError('Please enter a valid name');
        }
    };

    if (gameState === 'name') {
        return (
            <div style={{ textAlign: 'center', fontFamily: 'Arial, sans-serif', color: 'white', padding: '20px' }}>
                <h2>Welcome to Pong!</h2>
                <form onSubmit={handleNameSubmit}>
                    <label htmlFor="playerName">Enter your name:</label>
                    <input 
                        id="playerName"
                        type="text" 
                        value={playerName} 
                        onChange={(e) => setPlayerName(e.target.value)} 
                        style={{ fontSize: '18px', padding: '5px', margin: '10px' }}
                    />
                    <button type="submit" style={{ fontSize: '18px', padding: '5px 10px' }}>
                        Start Game
                    </button>
                </form>
                {inputError && <p style={{ color: 'red' }}>{inputError}</p>}
            </div>
        );
    }

    return (
        <div style={{ textAlign: 'center', fontFamily: 'Arial, sans-serif' }}>
            <canvas ref={canvasRef} width="800" height="400" style={{ border: '2px solid white' }} />
            <div style={{ marginTop: '20px', color: 'white' }}>
                <p>Player: {playerName} | Difficulty: {difficulty}</p>
            </div>
        </div>
    );
};

export default PongGame;
</file>

<file path="src/components/juegos/RenderPixelatedPass.js">
import * as THREE from 'three';
import { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';

export class RenderPixelatedPass extends Pass {
  constructor(resolution, scene, camera, options = {}) {
    super();
    this.resolution = new THREE.Vector2(resolution, resolution);
    this.scene = scene;
    this.camera = camera;
    this.edgeStrength = options.edgeStrength || 0.1;
    
    this.rgbRenderTarget = new THREE.WebGLRenderTarget(resolution, resolution, {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      type: THREE.UnsignedByteType
    });
    
    this.normalRenderTarget = new THREE.WebGLRenderTarget(resolution, resolution, {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      type: THREE.FloatType
    });

    this.depthRenderTarget = new THREE.WebGLRenderTarget(resolution, resolution, {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      type: THREE.FloatType
    });

    this.normalMaterial = new THREE.MeshNormalMaterial();
    this.depthMaterial = new THREE.MeshDepthMaterial();
    
    this.material = this.createPixelatedMaterial();
    this.fsQuad = new FullScreenQuad(this.material);
  }

  render(renderer, writeBuffer, readBuffer) {
    const oldRenderTarget = renderer.getRenderTarget();

    renderer.setRenderTarget(this.rgbRenderTarget);
    renderer.render(this.scene, this.camera);

    const oldOverrideMaterial = this.scene.overrideMaterial;
    
    this.scene.overrideMaterial = this.normalMaterial;
    renderer.setRenderTarget(this.normalRenderTarget);
    renderer.render(this.scene, this.camera);

    this.scene.overrideMaterial = this.depthMaterial;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.render(this.scene, this.camera);

    this.scene.overrideMaterial = oldOverrideMaterial;

    this.material.uniforms.tDiffuse.value = this.rgbRenderTarget.texture;
    this.material.uniforms.tNormal.value = this.normalRenderTarget.texture;
    this.material.uniforms.tDepth.value = this.depthRenderTarget.texture;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }

    renderer.setRenderTarget(oldRenderTarget);
  }

  createPixelatedMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        tNormal: { value: null },
        tDepth: { value: null },
        resolution: {
          value: new THREE.Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        },
        cameraNear: { value: this.camera.near },
        cameraFar: { value: this.camera.far },
        edgeStrength: { value: this.edgeStrength },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tNormal;
        uniform sampler2D tDepth;
        uniform vec4 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float edgeStrength;
        varying vec2 vUv;

        float getDepth(vec2 uv) {
          return texture2D(tDepth, uv).r;
        }

        vec3 getNormal(vec2 uv) {
          return texture2D(tNormal, uv).rgb * 2.0 - 1.0;
        }

        float getEdgeFactor(vec2 uv) {
          vec2 pixelSize = resolution.zw;

          float depth = getDepth(uv);
          vec3 normal = getNormal(uv);

          float depthDiff = 0.0;
          depthDiff += abs(depth - getDepth(uv + vec2(pixelSize.x, 0.0)));
          depthDiff += abs(depth - getDepth(uv - vec2(pixelSize.x, 0.0)));
          depthDiff += abs(depth - getDepth(uv + vec2(0.0, pixelSize.y)));
          depthDiff += abs(depth - getDepth(uv - vec2(0.0, pixelSize.y)));

          vec3 normalDiff = vec3(0.0);
          normalDiff += abs(normal - getNormal(uv + vec2(pixelSize.x, 0.0)));
          normalDiff += abs(normal - getNormal(uv - vec2(pixelSize.x, 0.0)));
          normalDiff += abs(normal - getNormal(uv + vec2(0.0, pixelSize.y)));
          normalDiff += abs(normal - getNormal(uv - vec2(0.0, pixelSize.y)));

          float depthEdge = smoothstep(0.01, 0.02, depthDiff);
          float normalEdge = smoothstep(0.1, 0.2, length(normalDiff));

          return max(depthEdge, normalEdge);
        }

        void main() {
          vec2 pixelatedUV = floor(vUv * resolution.xy) / resolution.xy;
          vec4 color = texture2D(tDiffuse, pixelatedUV);

          float edgeFactor = getEdgeFactor(pixelatedUV);
          vec3 edgeColor = vec3(1.0);  // White edge highlight

          // Subtle edge highlighting
          color.rgb = mix(color.rgb, edgeColor, edgeFactor * edgeStrength);

          gl_FragColor = color;
        }
      `
    });
  }
}
</file>

<file path="src/components/juegos/Runner3D.jsx">
// src/components/juegos/Runner3D.jsx

import React, { useRef, useEffect, useState, useCallback } from 'react';
import * as THREE from 'three';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

// --- Game Constants ---
const LANE_WIDTH = 4; // Ancho de cada carril imaginario
const NUM_LANES = 3; // Número de carriles
const TRACK_WIDTH = LANE_WIDTH * NUM_LANES;
const TRACK_LENGTH = 100; // Longitud visible del suelo a la vez
const PLAYER_SIZE = 1; // Tamaño del cubo del jugador
const PLAYER_COLOR = 0x3498db; // Azul
const GROUND_COLOR = 0x2c3e50; // Azul oscuro/gris
const OBSTACLE_COLOR = 0xe74c3c; // Rojo
const OBSTACLE_SIZE = PLAYER_SIZE;
const TEXT_COLOR = 0xffcc00; // Warmer gold color
const TEXT_EMISSIVE_COLOR = 0x443300; // Subtle dark gold glow

// --- Physics & Speed (ADJUSTED FOR 3D AND SLOWER PACE) ---
const GRAVITY = -15; // Gravedad (negativa en Y)
const JUMP_FORCE = 8;
const INITIAL_SPEED = 5; // <<< VELOCIDAD REDUCIDA
const SPEED_INCREMENT = 0.005; // <<< Incremento más lento
const OBSTACLE_SPAWN_Z = -TRACK_LENGTH / 2 - 10; // Dónde aparecen los obstáculos (lejos)
const OBSTACLE_DESPAWN_Z = 10; // Dónde desaparecen (detrás de la cámara)
const OBSTACLE_MIN_INTERVAL = 1.0; // Segundos mínimos entre spawns
const OBSTACLE_MAX_INTERVAL = 2.5; // Segundos máximos entre spawns

function Runner3D() {
    const mountRef = useRef(null);
    const gameRunningRef = useRef(true);
    const animationFrameId = useRef(null);
    const clock = useRef(new THREE.Clock());

    // --- Three.js Refs ---
    const rendererRef = useRef(null);
    const sceneRef = useRef(null);
    const cameraRef = useRef(null);
    const playerRef = useRef(null);
    const groundRef = useRef(null);
    const obstaclesGroupRef = useRef(null); // Grupo para mover todos los obstáculos
    const danteTextRef = useRef(null);

    // --- Game State Refs ---
    const playerState = useRef({
        y: PLAYER_SIZE / 2, // Posición inicial Y sobre el suelo
        velocityY: 0,
        isJumping: false,
        lane: Math.floor(NUM_LANES / 2), // Empezar en el carril central
    });
    const gameSpeedRef = useRef(INITIAL_SPEED);
    const scoreRef = useRef(0);
    const timeToNextObstacleRef = useRef(OBSTACLE_MIN_INTERVAL);
    const fontLoadedRef = useRef(false); // Para saber si la fuente está lista

    // --- React State ---
    const [score, setScore] = useState(0);
    const [gameOver, setGameOver] = useState(false);
    const [loadingFont, setLoadingFont] = useState(true);

    // --- Lane Calculation ---
    const getLaneX = (laneIndex) => {
        return (laneIndex - Math.floor(NUM_LANES / 2)) * LANE_WIDTH;
    };

    // --- Setup Scene ---
    useEffect(() => {
        const currentMount = mountRef.current;
        const { clientWidth: width, clientHeight: height } = currentMount;

        // Renderer
        rendererRef.current = new THREE.WebGLRenderer({ antialias: true });
        rendererRef.current.setSize(width, height);
        rendererRef.current.setClearColor(0x87CEEB); // Color cielo
        currentMount.appendChild(rendererRef.current.domElement);

        // Scene
        sceneRef.current = new THREE.Scene();

        // Camera
        cameraRef.current = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        cameraRef.current.position.set(0, PLAYER_SIZE * 1.7, 6); // Higher and further back
        cameraRef.current.lookAt(0, PLAYER_SIZE / 2, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        sceneRef.current.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        sceneRef.current.add(directionalLight);

        // Player
        const playerGeo = new THREE.BoxGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE);
        const playerMat = new THREE.MeshStandardMaterial({ color: PLAYER_COLOR });
        playerRef.current = new THREE.Mesh(playerGeo, playerMat);
        playerRef.current.position.x = getLaneX(playerState.current.lane);
        playerRef.current.position.y = playerState.current.y;
        sceneRef.current.add(playerRef.current);

        // Ground
        const groundGeo = new THREE.PlaneGeometry(TRACK_WIDTH, TRACK_LENGTH);
        const groundMat = new THREE.MeshStandardMaterial({ color: GROUND_COLOR });
        groundRef.current = new THREE.Mesh(groundGeo, groundMat);
        groundRef.current.rotation.x = -Math.PI / 2; // Rotar para que sea horizontal
        groundRef.current.position.y = 0; // Situado en Y=0
        sceneRef.current.add(groundRef.current);

        // Obstacles Group
        obstaclesGroupRef.current = new THREE.Group();
        sceneRef.current.add(obstaclesGroupRef.current);

        // Updated font loading and text creation
        const fontLoader = new FontLoader();
        fontLoader.load(
            '/helvetiker_regular.typeface.json',
            (font) => {
                console.log("Font loaded successfully");
                const textGeo = new TextGeometry('DANTE', {
                    font: font,
                    size: 4.5,   // Larger size
                    height: 0.6, // Thicker depth
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.2, // More pronounced bevel
                    bevelSize: 0.15,     // Wider bevel
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                textGeo.computeBoundingBox();
                const textWidth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;

                // Enhanced text material
                const textMat = new THREE.MeshStandardMaterial({
                    color: TEXT_COLOR,
                    metalness: 0.5,    // More metallic
                    roughness: 0.4,    // Less rough for more reflections
                    emissive: TEXT_EMISSIVE_COLOR,
                    emissiveIntensity: 0.5,
                    flatShading: false // Ensure smooth shading
                });

                danteTextRef.current = new THREE.Mesh(textGeo, textMat);
                danteTextRef.current.position.set(-textWidth / 2, PLAYER_SIZE * 3.5, OBSTACLE_SPAWN_Z + 15);
                sceneRef.current.add(danteTextRef.current);
                fontLoadedRef.current = true;
                setLoadingFont(false);
            },
            undefined,
            (error) => {
                console.error('Error loading font:', error);
                setLoadingFont(false);
            }
        );

        // Handle Resize
        const handleResize = () => {
            if (!currentMount) return;
            const { clientWidth: newWidth, clientHeight: newHeight } = currentMount;
            rendererRef.current.setSize(newWidth, newHeight);
            cameraRef.current.aspect = newWidth / newHeight;
            cameraRef.current.updateProjectionMatrix();
        };
        window.addEventListener('resize', handleResize);

        // Start Game Loop
        gameRunningRef.current = true;
        clock.current.start();
        resetGame(); // Initial setup of game state
        gameLoop();

        // Cleanup
        return () => {
            gameRunningRef.current = false;
            if (animationFrameId.current) {
                cancelAnimationFrame(animationFrameId.current);
            }
            window.removeEventListener('resize', handleResize);
            if (rendererRef.current && rendererRef.current.domElement && currentMount.contains(rendererRef.current.domElement)) {
                currentMount.removeChild(rendererRef.current.domElement);
            }
            // Dispose Three.js objects (importante para evitar leaks)
            playerGeo?.dispose();
            playerMat?.dispose();
            groundGeo?.dispose();
            groundMat?.dispose();
            obstaclesGroupRef.current?.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            danteTextRef.current?.geometry?.dispose();
            danteTextRef.current?.material?.dispose();
            sceneRef.current = null;
            cameraRef.current = null;
            rendererRef.current?.dispose(); // Dispose del renderer
            rendererRef.current = null;
        };
    }, []);

    // --- Game Logic ---

    const spawnObstacle = useCallback(() => {
        const obstacleGeo = new THREE.BoxGeometry(OBSTACLE_SIZE, OBSTACLE_SIZE * (1 + Math.random()), OBSTACLE_SIZE); // Altura variable
        const obstacleMat = new THREE.MeshStandardMaterial({ color: OBSTACLE_COLOR });
        const obstacle = new THREE.Mesh(obstacleGeo, obstacleMat);

        const lane = Math.floor(Math.random() * NUM_LANES);
        obstacle.position.x = getLaneX(lane);
        obstacle.position.y = obstacle.geometry.parameters.height / 2; // Apoyado en el suelo
        obstacle.position.z = OBSTACLE_SPAWN_Z;

        obstaclesGroupRef.current.add(obstacle);
    }, []);

    const updatePlayer = useCallback((delta) => {
        const state = playerState.current;
        state.y += state.velocityY * delta;

        if (state.isJumping) {
            state.velocityY += GRAVITY * delta;
        }

        // Colisión con el suelo
        if (state.y <= PLAYER_SIZE / 2) {
            state.y = PLAYER_SIZE / 2;
            state.velocityY = 0;
            state.isJumping = false;
        }

        playerRef.current.position.y = state.y;
        // Smoother lateral movement
        playerRef.current.position.x = THREE.MathUtils.lerp(
            playerRef.current.position.x,
            getLaneX(state.lane),
            0.1 // Slower, smoother movement
        );

    }, []);

    const updateObstacles = useCallback((delta) => {
        const speed = gameSpeedRef.current;
        const obstaclesToRemove = [];

        obstaclesGroupRef.current.position.z += speed * delta; // Mover el grupo entero

        obstaclesGroupRef.current.children.forEach(obstacle => {
            // Calcular posición real del obstáculo en el mundo
            const worldZ = obstacle.position.z + obstaclesGroupRef.current.position.z;

            // Eliminar obstáculos que han pasado la cámara
            if (worldZ > OBSTACLE_DESPAWN_Z) {
                obstaclesToRemove.push(obstacle);
            }
        });

        obstaclesToRemove.forEach(obstacle => {
            obstaclesGroupRef.current.remove(obstacle);
            // ¡Importante disponer geometría y material si no los reutilizas!
            obstacle.geometry.dispose();
            obstacle.material.dispose();
        });

        // Spawn Logic
        timeToNextObstacleRef.current -= delta;
        if (timeToNextObstacleRef.current <= 0) {
            spawnObstacle();
            timeToNextObstacleRef.current = OBSTACLE_MIN_INTERVAL + Math.random() * (OBSTACLE_MAX_INTERVAL - OBSTACLE_MIN_INTERVAL);
        }

    }, [spawnObstacle]); // Depende de spawnObstacle

    const checkCollisions = useCallback(() => {
        if (!playerRef.current) return false;

        const playerBox = new THREE.Box3().setFromObject(playerRef.current);

        for (const obstacle of obstaclesGroupRef.current.children) {
            const obstacleBox = new THREE.Box3();
            // IMPORTANT: Necesitamos calcular el bounding box en coordenadas MUNDIALES
            // ya que el obstáculo está dentro de un grupo que se mueve.
            obstacle.updateMatrixWorld(); // Asegura que la matriz mundial esté actualizada
            obstacleBox.setFromObject(obstacle, true); // El 'true' considera transformaciones de ancestros

            if (playerBox.intersectsBox(obstacleBox)) {
                return true; // Colisión detectada
            }
        }
        return false;
    }, []);


    const resetGame = useCallback(() => {
        playerState.current = {
            y: PLAYER_SIZE / 2,
            velocityY: 0,
            isJumping: false,
            lane: Math.floor(NUM_LANES / 2),
        };
        if (playerRef.current) {
            playerRef.current.position.y = playerState.current.y;
            playerRef.current.position.x = getLaneX(playerState.current.lane);
        }

        // Limpiar obstáculos existentes
        if (obstaclesGroupRef.current) {
            while (obstaclesGroupRef.current.children.length > 0) {
                const obj = obstaclesGroupRef.current.children[0];
                obstaclesGroupRef.current.remove(obj);
                obj.geometry?.dispose();
                obj.material?.dispose();
            }
            obstaclesGroupRef.current.position.z = 0; // Resetear posición del grupo
        }


        gameSpeedRef.current = INITIAL_SPEED;
        scoreRef.current = 0;
        timeToNextObstacleRef.current = OBSTACLE_MIN_INTERVAL;
        setScore(0);
        setGameOver(false);
        gameRunningRef.current = true; // Permitir que el loop corra
        clock.current.start(); // Reiniciar el reloj por si acaso

        // Asegurarse de que el loop se reinicie si estaba parado
        if (!animationFrameId.current && mountRef.current) {
            gameLoop();
        }

    }, []); // No dependencies that change often

    // --- Game Loop ---
    const gameLoop = useCallback(() => {
        if (!gameRunningRef.current || !rendererRef.current || !sceneRef.current || !cameraRef.current) {
            animationFrameId.current = null;
            if (gameOver) {
                // Podríamos renderizar una pantalla de game over aquí si quisiéramos
                console.log("Game Over - Final Score:", scoreRef.current);
            }
            return;
        }

        animationFrameId.current = requestAnimationFrame(gameLoop);

        const delta = clock.current.getDelta();

        // --- Updates ---
        updatePlayer(delta);
        updateObstacles(delta);

        // --- Speed & Score ---
        gameSpeedRef.current += SPEED_INCREMENT * delta;
        scoreRef.current += gameSpeedRef.current * delta * 1; // Puntuación basada en velocidad y tiempo
        setScore(Math.floor(scoreRef.current));

        // --- Collision Check ---
        if (checkCollisions()) {
            gameRunningRef.current = false;
            setGameOver(true);
            // El loop terminará en la siguiente iteración al chequear gameRunningRef.current
        }

        // --- Render ---
        rendererRef.current.render(sceneRef.current, cameraRef.current);

    }, [gameOver, updatePlayer, updateObstacles, checkCollisions]); // Add dependencies

    // --- Input Handler ---
    const handleKeyDown = useCallback((event) => {
        if (loadingFont) return; // No hacer nada si la fuente aún no carga

        if (gameOver && event.code === 'KeyR') {
            resetGame();
        } else if (!gameOver) {
            const state = playerState.current;
            switch (event.code) {
                case 'Space':
                case 'ArrowUp':
                    if (!state.isJumping) {
                        state.velocityY = JUMP_FORCE;
                        state.isJumping = true;
                    }
                    break;
                case 'ArrowLeft':
                    // Mover a la izquierda si no estamos en el carril más a la izquierda
                    state.lane = Math.max(0, state.lane - 1);
                    break;
                case 'ArrowRight':
                    // Mover a la derecha si no estamos en el carril más a la derecha
                    state.lane = Math.min(NUM_LANES - 1, state.lane + 1);
                    break;
                // Añadir 'ArrowDown' para agacharse si se implementa
            }
        }
    }, [gameOver, resetGame, loadingFont]); // Add loadingFont dependency

    // Effect for input listener
    useEffect(() => {
        window.addEventListener('keydown', handleKeyDown);
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [handleKeyDown]); // Depend on handleKeyDown

    return (
        <div style={{ width: '100%', maxWidth: '800px', height: '400px', margin: '1rem auto', border: '1px solid #ccc', position: 'relative' }}>
            {loadingFont && <div style={overlayStyle}>Loading 3D Assets...</div>}
            {gameOver && (
                <div style={overlayStyle}>
                    <p style={{ fontSize: '2em', marginBottom: '0.5em' }}>GAME OVER</p>
                    <p>Final Score: {Math.floor(scoreRef.current)}</p>
                    <p>Press R to Retry</p>
                </div>
            )}
            <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
        </div>
    );
}

const overlayStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    color: 'white',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10, // Asegurar que esté sobre el canvas
    fontSize: '1.5em',
    textAlign: 'center'
};


export default Runner3D;
</file>

<file path="src/components/juegos/SnakeGame.css">
.game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Arial', sans-serif;
    position: relative;
    overflow: hidden;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    box-sizing: border-box;
  }
  
  .background-name {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-30deg);
    font-size: 150px;
    font-weight: bold;
    color: rgba(0, 0, 0, 0.03);
    z-index: -1;
    user-select: none;
    white-space: nowrap;
    overflow: hidden;
    text-transform: uppercase;
    letter-spacing: 10px;
  }
  
  canvas {
    border: 3px solid #333;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    position: relative;
    z-index: 1;
    max-width: 100%;
    height: auto;
  }
  
  .score-board {
    font-size: 24px;
    margin: 20px 0;
    position: relative;
    z-index: 2;
    background-color: rgba(255, 255, 255, 0.1);
    padding: 10px 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  
  .game-over-overlay,
  .instructions-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 24px;
    z-index: 3;
    text-align: center;
    padding: 20px;
  }
  
  .instructions-overlay {
    background: rgba(0, 0, 0, 0.9);
  }
  
  .instructions-overlay h2 {
    margin-bottom: 20px;
  }
  
  .instructions-overlay ul {
    list-style-type: none;
    padding: 0;
    margin-bottom: 20px;
  }
  
  .instructions-overlay li {
    margin: 10px 0;
  }
  
  .game-over-overlay div,
  .instructions-overlay p {
    margin: 10px 0;
  }
  
  .restart-button,
  .start-button {
    margin-top: 20px;
    padding: 12px 24px;
    font-size: 18px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  .restart-button:hover,
  .start-button:hover {
    background-color: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .restart-button:active,
  .start-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  
  @media (max-width: 600px) {
    .background-name {
      font-size: 100px;
    }
  
    .score-board {
      font-size: 18px;
    }
  
    .game-over-overlay,
    .instructions-overlay {
      font-size: 20px;
    }
  
    .restart-button,
    .start-button {
      padding: 10px 20px;
      font-size: 16px;
    }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  .game-container {
    animation: fadeIn 0.5s ease-in;
  }
</file>

<file path="src/components/juegos/SnakeGame.js">
import React, { useRef, useEffect, useState, useCallback } from 'react';
import './SnakeGame.css';

const SnakeGame = () => {
  const canvasRef = useRef(null);
  const [snake, setSnake] = useState([{ x: 2, y: 2 }]);
  const [food, setFood] = useState({ x: 5, y: 5 });
  const [direction, setDirection] = useState('RIGHT');
  const [gameOver, setGameOver] = useState(false);
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [level, setLevel] = useState(1);
  const [obstacles, setObstacles] = useState([]);
  const [showInstructions, setShowInstructions] = useState(true);

  const cellSize = 20;
  const canvasSize = 400;

  const generateFood = useCallback(() => {
    let newFood;
    do {
      newFood = {
        x: Math.floor(Math.random() * (canvasSize / cellSize)),
        y: Math.floor(Math.random() * (canvasSize / cellSize))
      };
    } while (
      snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
      obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y)
    );
    return newFood;
  }, [snake, obstacles, canvasSize, cellSize]);

  const generateObstacles = useCallback(() => {
    const newObstacles = [];
    for (let i = 0; i < level; i++) {
      let obstacle;
      do {
        obstacle = {
          x: Math.floor(Math.random() * (canvasSize / cellSize)),
          y: Math.floor(Math.random() * (canvasSize / cellSize))
        };
      } while (
        snake.some(segment => segment.x === obstacle.x && segment.y === obstacle.y) ||
        (food.x === obstacle.x && food.y === obstacle.y) ||
        newObstacles.some(obs => obs.x === obstacle.x && obs.y === obstacle.y)
      );
      newObstacles.push(obstacle);
    }
    setObstacles(newObstacles);
  }, [level, snake, food, canvasSize, cellSize]);

  const drawGame = useCallback((ctx) => {
    ctx.clearRect(0, 0, canvasSize, canvasSize);

    // Draw snake
    ctx.fillStyle = '#4CAF50';
    snake.forEach((segment, index) => {
      const brightness = 1 - index * 0.05;
      ctx.fillStyle = `rgba(76, 175, 80, ${brightness})`;
      ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize - 1, cellSize - 1);
    });

    // Draw food
    ctx.fillStyle = '#FF4136';
    ctx.beginPath();
    ctx.arc(
      (food.x * cellSize) + cellSize / 2,
      (food.y * cellSize) + cellSize / 2,
      cellSize / 2,
      0,
      2 * Math.PI
    );
    ctx.fill();

    // Draw obstacles
    ctx.fillStyle = '#333333';
    obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x * cellSize, obstacle.y * cellSize, cellSize, cellSize);
    });

    // Draw border
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, canvasSize, canvasSize);
  }, [snake, food, obstacles, canvasSize, cellSize]);

  const moveSnake = useCallback(() => {
    const newSnake = [...snake];
    const head = { ...newSnake[0] };

    switch (direction) {
      case 'UP': head.y -= 1; break;
      case 'DOWN': head.y += 1; break;
      case 'LEFT': head.x -= 1; break;
      case 'RIGHT': head.x += 1; break;
      default: break;
    }

    // Wrap around edges
    if (head.x < 0) head.x = canvasSize / cellSize - 1;
    if (head.x >= canvasSize / cellSize) head.x = 0;
    if (head.y < 0) head.y = canvasSize / cellSize - 1;
    if (head.y >= canvasSize / cellSize) head.y = 0;

    // Check collisions
    if (
      newSnake.some(segment => segment.x === head.x && segment.y === head.y) ||
      obstacles.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)
    ) {
      setGameOver(true);
      return;
    }

    newSnake.unshift(head);

    // Check food collision
    if (head.x === food.x && head.y === food.y) {
      setScore(prevScore => {
        const newScore = prevScore + 1;
        if (newScore > highScore) {
          setHighScore(newScore);
          localStorage.setItem('snakeHighScore', newScore);
        }
        if (newScore % 5 === 0) {
          setLevel(prevLevel => prevLevel + 1);
          generateObstacles();
        }
        return newScore;
      });
      setFood(generateFood());
    } else {
      newSnake.pop();
    }

    setSnake(newSnake);
  }, [snake, direction, food, obstacles, generateFood, generateObstacles, highScore, canvasSize, cellSize]);

  const handleKeyPress = useCallback((event) => {
    switch (event.key.toLowerCase()) {
      case 'w': if (direction !== 'DOWN') setDirection('UP'); break;
      case 's': if (direction !== 'UP') setDirection('DOWN'); break;
      case 'a': if (direction !== 'RIGHT') setDirection('LEFT'); break;
      case 'd': if (direction !== 'LEFT') setDirection('RIGHT'); break;
      default: break;
    }
  }, [direction]);

  const restartGame = useCallback(() => {
    setSnake([{ x: 2, y: 2 }]);
    setFood(generateFood());
    setDirection('RIGHT');
    setGameOver(false);
    setScore(0);
    setLevel(1);
    setObstacles([]);
    setShowInstructions(true);
  }, [generateFood]);

  useEffect(() => {
    const storedHighScore = localStorage.getItem('snakeHighScore');
    if (storedHighScore) setHighScore(parseInt(storedHighScore, 10));

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const gameLoop = setInterval(() => {
      if (!gameOver && !showInstructions) {
        moveSnake();
        drawGame(ctx);
      }
    }, 100);

    window.addEventListener('keydown', handleKeyPress);

    return () => {
      clearInterval(gameLoop);
      window.removeEventListener('keydown', handleKeyPress);
    };
  }, [drawGame, moveSnake, handleKeyPress, gameOver, showInstructions, generateFood]);

  return (
    <div className="game-container">
      <div className="background-name">Dante</div>
      <div className="score-board">Score: {score} | High Score: {highScore} | Level: {level}</div>
      <canvas ref={canvasRef} width={canvasSize} height={canvasSize} />
      {showInstructions && (
        <div className="instructions-overlay">
          <h2>Snake Game Instructions</h2>
          <p>Use WASD keys to control the snake:</p>
          <ul>
            <li>W: Move Up</li>
            <li>A: Move Left</li>
            <li>S: Move Down</li>
            <li>D: Move Right</li>
          </ul>
          <p>Eat the red food to grow and gain points.</p>
          <p>Avoid hitting the walls, obstacles, or yourself!</p>
          <button className="start-button" onClick={() => setShowInstructions(false)}>Start Game</button>
        </div>
      )}
      {gameOver && (
        <div className="game-over-overlay">
          <div>Game Over!</div>
          <div>Your Score: {score}</div>
          <div>Level Reached: {level}</div>
          <button className="restart-button" onClick={restartGame}>Restart Game</button>
        </div>
      )}
    </div>
  );
};

export default SnakeGame;
</file>

<file path="src/components/juegos/SnakeGame3D.js">
import React, { useEffect, useRef, useState } from 'react';
import * as BABYLON from 'babylonjs';

const EnhancedSnakeGame3D = () => {
  const canvasRef = useRef(null);
  const [gameStarted, setGameStarted] = useState(false);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const sceneRef = useRef(null);
  const snakeRef = useRef([]);
  const directionRef = useRef(new BABYLON.Vector3(1, 0, 0));
  const foodRef = useRef(null);
  const moveIntervalRef = useRef(null);
  const speedRef = useRef(300);
  const foodsEatenRef = useRef(0);

  useEffect(() => {
    const canvas = canvasRef.current;
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = () => {
      const scene = new BABYLON.Scene(engine);

      const camera = new BABYLON.ArcRotateCamera(
        "camera",
        -Math.PI / 2,
        Math.PI / 3,
        35,
        new BABYLON.Vector3(0, 0, 0),
        scene
      );
      camera.upperBetaLimit = Math.PI / 2.2;
      camera.lowerRadiusLimit = 30;
      camera.upperRadiusLimit = 50;
      camera.attachControl(canvas, true);

      new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
      const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
      dirLight.intensity = 0.6;

      const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 35, height: 18 }, scene);
      const groundMaterial = new BABYLON.StandardMaterial('groundMat', scene);
      
      const texture = new BABYLON.DynamicTexture('dynamic texture', { width: 1024, height: 512 }, scene);
      groundMaterial.diffuseTexture = texture;

      const context = texture.getContext();
      const width = 1024;
      const height = 512;
      const numberOfSquaresX = 16;
      const numberOfSquaresY = 8;
      const squareSizeX = width / numberOfSquaresX;
      const squareSizeY = height / numberOfSquaresY;

      for (let i = 0; i < numberOfSquaresX; i++) {
        for (let j = 0; j < numberOfSquaresY; j++) {
          const baseColor = (i + j) % 2 === 0 ? '#8a8a8a' : '#4a4a4a';
          context.fillStyle = baseColor;
          context.fillRect(i * squareSizeX, j * squareSizeY, squareSizeX, squareSizeY);

          const gradient = context.createRadialGradient(
            i * squareSizeX, j * squareSizeY, 0,
            i * squareSizeX, j * squareSizeY, squareSizeX / 2
          );
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          context.fillStyle = gradient;
          context.fillRect(i * squareSizeX, j * squareSizeY, squareSizeX, squareSizeY);
        }
      }

      texture.update();
      ground.material = groundMaterial;

      groundMaterial.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
      groundMaterial.specularPower = 64;

      const borderMaterial = new BABYLON.StandardMaterial('borderMat', scene);
      borderMaterial.diffuseColor = new BABYLON.Color3.FromHexString('#ffd700');
      borderMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

      const createBorder = (name, dimensions, position) => {
        const border = BABYLON.MeshBuilder.CreateBox(name, dimensions, scene);
        border.position = position;
        border.material = borderMaterial;
        return border;
      };

      createBorder('borderTop', { width: 35, height: 0.2, depth: 0.2 }, new BABYLON.Vector3(0, 0.1, 9));
      createBorder('borderBottom', { width: 35, height: 0.2, depth: 0.2 }, new BABYLON.Vector3(0, 0.1, -9));
      createBorder('borderLeft', { width: 0.2, height: 0.2, depth: 18 }, new BABYLON.Vector3(-17.5, 0.1, 0));
      createBorder('borderRight', { width: 0.2, height: 0.2, depth: 18 }, new BABYLON.Vector3(17.5, 0.1, 0));

      return scene;
    };

    const scene = createScene();
    sceneRef.current = scene;

    engine.runRenderLoop(() => {
      scene.render();
    });

    window.addEventListener('resize', () => {
      engine.resize();
    });

    return () => {
      engine.dispose();
    };
  }, []);

  const startGame = () => {
    setGameStarted(true);
    setGameOver(false);
    setScore(0);
    speedRef.current = 300;
    foodsEatenRef.current = 0;
    const scene = sceneRef.current;

    scene.meshes.slice().forEach((mesh) => {
      if (!['ground', 'borderTop', 'borderBottom', 'borderLeft', 'borderRight'].includes(mesh.name)) {
        mesh.dispose();
      }
    });

    foodRef.current = null;

    snakeRef.current = [];
    directionRef.current = new BABYLON.Vector3(1, 0, 0);

    const snakeHead = BABYLON.MeshBuilder.CreateBox('snakeHead', { size: 1 }, scene);
    const snakeMaterial = new BABYLON.StandardMaterial('snakeMat', scene);
    snakeMaterial.diffuseColor = BABYLON.Color3.Green();
    snakeHead.material = snakeMaterial;
    snakeHead.position = new BABYLON.Vector3(-15, 0.5, 0);
    snakeRef.current.push(snakeHead);

    createFood();

    if (moveIntervalRef.current) {
      clearInterval(moveIntervalRef.current);
    }
    moveIntervalRef.current = setInterval(moveSnake, speedRef.current);

    window.removeEventListener('keydown', handleKeyDown);
    window.addEventListener('keydown', handleKeyDown);
  };

  const createFood = () => {
    const scene = sceneRef.current;
    const food = BABYLON.MeshBuilder.CreateSphere('food', { diameter: 1 }, scene);
    const foodMaterial = new BABYLON.StandardMaterial('foodMat', scene);
    foodMaterial.diffuseColor = BABYLON.Color3.Red();
    food.material = foodMaterial;
    food.position = new BABYLON.Vector3(
      Math.floor(Math.random() * 33 - 16.5),
      0.5,
      Math.floor(Math.random() * 16 - 8)
    );
    foodRef.current = food;
  };

  const moveSnake = () => {
    const scene = sceneRef.current;
    const snake = snakeRef.current;
    const head = snake[0];
    const newHeadPos = head.position.add(directionRef.current);

    if (Math.abs(newHeadPos.x) > 17 || Math.abs(newHeadPos.z) > 8.5) {
      gameOverFunction();
      return;
    }

    for (let i = 1; i < snake.length; i++) {
      if (BABYLON.Vector3.Distance(newHeadPos, snake[i].position) < 0.1) {
        gameOverFunction();
        return;
      }
    }

    if (foodRef.current && BABYLON.Vector3.Distance(newHeadPos, foodRef.current.position) < 1) {
      foodRef.current.dispose();
      createFood();
      setScore((prevScore) => prevScore + 10);

      foodsEatenRef.current += 1;

      if (foodsEatenRef.current % 3 === 0 && speedRef.current > 100) {
        speedRef.current -= 50;
        clearInterval(moveIntervalRef.current);
        moveIntervalRef.current = setInterval(moveSnake, speedRef.current);
      }

      const newSegment = BABYLON.MeshBuilder.CreateBox('snakeSegment', { size: 1 }, scene);
      const snakeMaterial = new BABYLON.StandardMaterial('snakeMat', scene);
      snakeMaterial.diffuseColor = BABYLON.Color3.Green();
      newSegment.material = snakeMaterial;
      newSegment.position = snake[snake.length - 1].position.clone();
      snake.push(newSegment);
    }

    for (let i = snake.length - 1; i > 0; i--) {
      snake[i].position = snake[i - 1].position.clone();
    }

    head.position = newHeadPos;
  };

  const handleKeyDown = (event) => {
    const key = event.key;
    switch (key) {
      case 'w':
      case 'ArrowUp':
        if (!directionRef.current.equals(new BABYLON.Vector3(0, 0, -1))) {
          directionRef.current = new BABYLON.Vector3(0, 0, 1);
        }
        break;
      case 's':
      case 'ArrowDown':
        if (!directionRef.current.equals(new BABYLON.Vector3(0, 0, 1))) {
          directionRef.current = new BABYLON.Vector3(0, 0, -1);
        }
        break;
      case 'a':
      case 'ArrowLeft':
        if (!directionRef.current.equals(new BABYLON.Vector3(1, 0, 0))) {
          directionRef.current = new BABYLON.Vector3(-1, 0, 0);
        }
        break;
      case 'd':
      case 'ArrowRight':
        if (!directionRef.current.equals(new BABYLON.Vector3(-1, 0, 0))) {
          directionRef.current = new BABYLON.Vector3(1, 0, 0);
        }
        break;
      default:
        break;
    }
  };

  const gameOverFunction = () => {
    clearInterval(moveIntervalRef.current);
    window.removeEventListener('keydown', handleKeyDown);
    setGameStarted(false);
    setGameOver(true);
  };

  const Instructions = () => (
    <div style={{
      position: 'absolute',
      top: '10%',
      left: '50%',
      transform: 'translateX(-50%)',
      color: 'white',
      textAlign: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      padding: '20px',
      borderRadius: '10px',
      zIndex: 2,
      width: '80%',
      maxWidth: '400px',
    }}>
      <h2>Instructions</h2>
      <p>Use arrow keys or WASD to move the snake</p>
      <p>Left click + drag: Rotate camera</p>
      <p>Right click + drag: Move camera</p>
      <p>Mouse wheel: Zoom</p>
    </div>
  );

  return (
    <div
      style={{
        width: '100%',
        height: '400px',
        position: 'relative',
      }}
    >
      <canvas ref={canvasRef} style={{ width: '100%', height: '100%' }} />
      {gameStarted && (
        <div
          style={{
            position: 'absolute',
            top: 10,
            left: 10,
            color: 'white',
            fontSize: '20px',
            zIndex: 1,
          }}
        >
          Score: {score} | Speed: {(1000 / speedRef.current).toFixed(1)} moves/sec
        </div>
      )}
      {!gameStarted && !gameOver && (
        <>
          <Instructions />
          <button
            onClick={startGame}
            style={{
              position: 'absolute',
              zIndex: 2,
              bottom: '10%',
              left: '50%',
              transform: 'translateX(-50%)',
              padding: '10px 20px',
              fontSize: '24px',
              cursor: 'pointer',
              borderRadius: '5px',
              backgroundColor: '#4CAF50',
              color: 'white',
              border: 'none',
            }}
          >
            Start Game
          </button>
        </>
      )}
      {gameOver && (
        <div
          style={{
            position: 'absolute',
            zIndex: 2,
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            textAlign: 'center',
            backgroundColor: 'rgba(0, 0, 0, 0.7)',
            padding: '20px',
            borderRadius: '10px',
          }}
        >
          <h1>Game Over!</h1>
          <p>Your Score: {score}</p>
          <button
            onClick={startGame}
            style={{
              padding: '10px 20px',
              fontSize: '24px',
              cursor: 'pointer',
              borderRadius: '5px',
              backgroundColor: '#4CAF50',
              color: 'white',
              border: 'none',
            }}
          >
            Restart
          </button>
        </div>
      )}
    </div>
  );
};

export default EnhancedSnakeGame3D;
</file>

<file path="src/components/juegos/Terminal.js">
import React, { useEffect, useRef, useState } from 'react';
import { Terminal as XTerm } from 'xterm';
import { FitAddon } from 'xterm-addon-fit';
import { WebLinksAddon } from 'xterm-addon-web-links';
import { SearchAddon } from 'xterm-addon-search';
import { Maximize2, Minimize2, X, Terminal as TerminalIcon } from 'lucide-react';
import 'xterm/css/xterm.css';

// Matrix effect function
const startMatrixEffect = (term) => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%^&*';
  const width = Math.floor(term.cols / 2);
  const streams = Array(width).fill(0);
  
  const interval = setInterval(() => {
    let output = '';
    streams.forEach((_, i) => {
      const char = chars[Math.floor(Math.random() * chars.length)];
      output += (i === 0 ? '' : ' ') + '\x1b[32m' + char + '\x1b[0m';
    });
    term.writeln(output);
  }, 100);

  // Stop after 5 seconds
  setTimeout(() => {
    clearInterval(interval);
    term.write('\x1b[1;36m➜\x1b[0m ');
  }, 5000);
};

const Terminal = () => {
  const terminalRef = useRef(null);
  const xtermRef = useRef(null);
  const [isMaximized, setIsMaximized] = useState(false);
  const [title] = useState('Terminal');

  useEffect(() => {
    if (xtermRef.current) {
      const fitAddon = new FitAddon();
      xtermRef.current.loadAddon(fitAddon);
      setTimeout(() => fitAddon.fit(), 0);
    }
  }, [isMaximized]);

  useEffect(() => {
    const term = new XTerm({
      allowProposedApi: true,
      cursorBlink: true,
      cursorStyle: 'bar',
      fontSize: 14,
      fontFamily: '"Cascadia Code", Menlo, "DejaVu Sans Mono", Consolas, "Lucida Console", monospace',
      letterSpacing: 0,
      lineHeight: 1.2,
      theme: {
        background: '#1a1b26',
        foreground: '#a9b1d6',
        cursor: '#528bff',
        selection: '#28324a',
        black: '#32344a',
        brightBlack: '#444b6a',
        red: '#f7768e',
        brightRed: '#ff7a93',
        green: '#9ece6a',
        brightGreen: '#b9f27c',
        yellow: '#e0af68',
        brightYellow: '#ff9e64',
        blue: '#7aa2f7',
        brightBlue: '#7da6ff',
        magenta: '#ad8ee6',
        brightMagenta: '#bb9af7',
        cyan: '#449dab',
        brightCyan: '#0db9d7',
        white: '#787c99',
        brightWhite: '#acb0d0'
      }
    });

    const fitAddon = new FitAddon();
    const searchAddon = new SearchAddon();
    
    term.loadAddon(fitAddon);
    term.loadAddon(searchAddon);
    term.loadAddon(new WebLinksAddon());

    term.open(terminalRef.current);
    fitAddon.fit();
    xtermRef.current = term;

    term.writeln('\x1b[1;34m╭────────────────────────────────────────────╮\x1b[0m');
    term.writeln('\x1b[1;34m│\x1b[0m  \x1b[1;32mWelcome to Enhanced Terminal\x1b[0m          \x1b[1;34m│\x1b[0m');
    term.writeln('\x1b[1;34m│\x1b[0m  \x1b[1;36mBy Dante Collazzi\x1b[0m                     \x1b[1;34m│\x1b[0m');
    term.writeln('\x1b[1;34m╰────────────────────────────────────────────╯\x1b[0m');
    term.writeln('');
    term.writeln('\x1b[1;33mAvailable commands:\x1b[0m');
    term.writeln('  \x1b[1;32mhelp\x1b[0m      - Show this help message');
    term.writeln('  \x1b[1;32mclear\x1b[0m     - Clear the terminal screen');
    term.writeln('  \x1b[1;32mdate\x1b[0m      - Display current date and time');
    term.writeln('  \x1b[1;32msystem\x1b[0m    - Display system information');
    term.writeln('  \x1b[1;32mmatrix\x1b[0m    - Display Matrix effect');
    term.writeln('  \x1b[1;32mcolor\x1b[0m     - Show terminal colors');
    term.writeln('  \x1b[1;32mbanner\x1b[0m    - Display ASCII art banner');
    term.writeln('');
    term.write('\x1b[1;36m➜\x1b[0m ');

    let currentLine = '';
    let history = [];
    let historyIndex = -1;

    term.onKey(({ key, domEvent }) => {
      const char = key;
      
      switch (domEvent.keyCode) {
        case 13: // Enter
          term.write('\r\n');
          if (currentLine.trim()) {
            history.push(currentLine);
            historyIndex = history.length;
            processCommand(currentLine.trim(), term);
          }
          currentLine = '';
          term.write('\x1b[1;36m➜\x1b[0m ');
          break;
          
        case 38: // Up arrow
          if (historyIndex > 0) {
            historyIndex--;
            term.write('\r\x1b[K\x1b[1;36m➜\x1b[0m ' + history[historyIndex]);
            currentLine = history[historyIndex];
          }
          break;
          
        case 40: // Down arrow
          if (historyIndex < history.length - 1) {
            historyIndex++;
            term.write('\r\x1b[K\x1b[1;36m➜\x1b[0m ' + history[historyIndex]);
            currentLine = history[historyIndex];
          } else {
            historyIndex = history.length;
            term.write('\r\x1b[K\x1b[1;36m➜\x1b[0m ');
            currentLine = '';
          }
          break;
          
        case 8: // Backspace
          if (currentLine.length > 0) {
            currentLine = currentLine.slice(0, -1);
            term.write('\b \b');
          }
          break;
          
        default:
          if (char.length === 1) {
            currentLine += char;
            term.write(char);
          }
      }
    });

    const handleResize = () => {
      fitAddon.fit();
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (xtermRef.current) {
        xtermRef.current.dispose();
      }
    };
  }, []);

  const processCommand = (input, term) => {
    const cmd = input.toLowerCase();
    
    switch (cmd) {
      case 'help':
        term.writeln('\x1b[1;33mAvailable commands:\x1b[0m');
        term.writeln('  \x1b[1;32mhelp\x1b[0m      - Show this help message');
        term.writeln('  \x1b[1;32mclear\x1b[0m     - Clear the terminal screen');
        term.writeln('  \x1b[1;32mdate\x1b[0m      - Display current date and time');
        term.writeln('  \x1b[1;32msystem\x1b[0m    - Display system information');
        term.writeln('  \x1b[1;32mmatrix\x1b[0m    - Display Matrix effect');
        term.writeln('  \x1b[1;32mcolor\x1b[0m     - Show terminal colors');
        term.writeln('  \x1b[1;32mbanner\x1b[0m    - Display ASCII art banner');
        break;
        
      case 'clear':
        term.clear();
        break;
        
      case 'date':
        term.writeln('\x1b[1;34m' + new Date().toLocaleString() + '\x1b[0m');
        break;
        
      case 'system':
        term.writeln('\x1b[1;35mSystem Information:\x1b[0m');
        term.writeln('  \x1b[33m→\x1b[0m OS: ' + navigator.platform);
        term.writeln('  \x1b[33m→\x1b[0m Browser: ' + navigator.userAgent.split(' ').pop());
        term.writeln('  \x1b[33m→\x1b[0m Resolution: ' + window.innerWidth + 'x' + window.innerHeight);
        break;
        
      case 'matrix':
        startMatrixEffect(term);
        break;

      case 'color':
        term.writeln('\x1b[1;31mRed\x1b[0m');
        term.writeln('\x1b[1;32mGreen\x1b[0m');
        term.writeln('\x1b[1;33mYellow\x1b[0m');
        term.writeln('\x1b[1;34mBlue\x1b[0m');
        term.writeln('\x1b[1;35mMagenta\x1b[0m');
        term.writeln('\x1b[1;36mCyan\x1b[0m');
        break;

      case 'banner':
        term.writeln('\x1b[1;35m');
        term.writeln('   ____              _       ');
        term.writeln('  |  _ \\  __ _ _ __ | |_ ___ ');
        term.writeln('  | | | |/ _` | \'_ \\| __/ _ \\');
        term.writeln('  | |_| | (_| | | | | ||  __/');
        term.writeln('  |____/ \\__,_|_| |_|\\__\\___|');
        term.writeln('\x1b[0m');
        break;

      default:
        if (cmd.startsWith('echo ')) {
          term.writeln(cmd.slice(5));
        } else {
          term.writeln('\x1b[1;31mCommand not found:\x1b[0m ' + cmd);
        }
    }
  };

  return (
    <div className={`${isMaximized ? 'fixed inset-0 z-50 p-4 bg-gray-900/90' : 'w-full h-96'} transition-all duration-300`}>
      <div className="flex flex-col h-full bg-gray-900 rounded-lg overflow-hidden shadow-2xl border border-gray-700">
        <div className="flex items-center justify-between px-4 py-2 bg-gray-800 border-b border-gray-700">
          <div className="flex items-center space-x-2">
            <TerminalIcon size={16} className="text-green-500" />
            <span className="text-sm font-medium text-gray-200">{title}</span>
          </div>
          
          <div className="flex items-center space-x-2">
            <button
              onClick={() => setIsMaximized(!isMaximized)}
              className="p-1 hover:bg-gray-700 rounded"
            >
              {isMaximized ? 
                <Minimize2 size={14} className="text-gray-400 hover:text-gray-200" /> :
                <Maximize2 size={14} className="text-gray-400 hover:text-gray-200" />
              }
            </button>
            <button
              onClick={() => xtermRef.current?.clear()}
              className="p-1 hover:bg-gray-700 rounded"
            >
              <X size={14} className="text-gray-400 hover:text-gray-200" />
            </button>
          </div>
        </div>

        <div className="flex-1 relative">
          <div 
            ref={terminalRef}
            className="absolute inset-0"
          />
        </div>
      </div>
    </div>
  );
};

export default Terminal;
</file>

<file path="src/components/shaders/ParticleSystem.js">
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';

function ParticleSystem() {
  const ref = useRef();
  const frameId = useRef();
  const [radius, setRadius] = useState(1); // Estado para el radio

  useEffect(() => {
    const currentRef = ref.current;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, currentRef.clientWidth / currentRef.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(currentRef.clientWidth, currentRef.clientHeight);
    currentRef.appendChild(renderer.domElement);

    const particlesCount = 6000; // El número de partículas
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    const colors = new Float32Array(particlesCount * 3); // Array para los colores
    const targetPositions = [];
    const angleStep = (Math.PI * 2) / particlesCount;

    for (let i = 0; i < particlesCount; i++) {
      positions[i * 3] = Math.random() * 2 - 1; // x
      positions[i * 3 + 1] = Math.random() * 2 - 1; // y
      positions[i * 3 + 2] = Math.random() * 2 - 1; // z

      const angle = angleStep * i;
      targetPositions.push(Math.cos(angle), Math.sin(angle), 0);

      colors[i * 3] = Math.random();     // R
      colors[i * 3 + 1] = Math.random(); // G
      colors[i * 3 + 2] = Math.random(); // B
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const particlesMaterial = new THREE.PointsMaterial({
      size: 0.02,
      vertexColors: true,
    });

    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);

    camera.position.z = 2.5;


    

    const animateParticles = () => {
      const positions = particlesGeometry.attributes.position.array;
  
      for (let i = 0; i < particlesCount; i++) {
        const targetX = Math.cos(angleStep * i) * radius;
        const targetY = Math.sin(angleStep * i) * radius;
  
        positions[i * 3] += (targetX - positions[i * 3]) * 0.01;
        positions[i * 3 + 1] += (targetY - positions[i * 3 + 1]) * 0.01;
      }
  
      particlesGeometry.attributes.position.needsUpdate = true;
    };
    
    const animate = () => {
      frameId.current = requestAnimationFrame(animate);
      animateParticles();
      renderer.render(scene, camera);
    };

    animate();

    const handleResize = () => {
      const width = currentRef.clientWidth;
      const height = currentRef.clientHeight;
  
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
  
      const newRadius = width < 600 ? 0.5 : 1;
      setRadius(newRadius); // Actualiza el radio
    };
    
    window.addEventListener('resize', handleResize);
    


    return () => {
      cancelAnimationFrame(frameId.current);
      currentRef.removeChild(renderer.domElement);
      window.removeEventListener('resize', handleResize);
      scene.clear();
    };
  }, [radius]);

  return <div ref={ref} style={{ width: '100%', height: '100%' }} />;
}

export default ParticleSystem;
</file>

<file path="src/components/shaders/TorusKnot.js">
import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';

function TorusKnot() {
  const ref = useRef();
  const frameId = useRef();

  useEffect(() => {
    const currentRef = ref.current;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, currentRef.clientWidth / currentRef.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(currentRef.clientWidth, currentRef.clientHeight);
    currentRef.appendChild(renderer.domElement);

    // Material para el toro anudado
    const material = new THREE.MeshPhysicalMaterial({
      color: '#4e62f9',
      // Aquí puedes añadir más propiedades como roughness o metalness si lo deseas
    });

    // Geometría para el toro anudado
    const geometry = new THREE.TorusKnotGeometry(1, 0.4, 100, 100);
    const torusKnot = new THREE.Mesh(geometry, material);
    scene.add(torusKnot);

    camera.position.z = 5; // Puede que necesites ajustar esto para que el toro anudado quepa en la vista de la cámara

    // Función de animación
    const animate = () => {
      frameId.current = requestAnimationFrame(animate);
      torusKnot.rotation.x += 0.01;
      torusKnot.rotation.y += 0.01;
      renderer.render(scene, camera);
    };

    // Iniciar la animación
    animate();

    // Manejar redimensionamiento del contenedor
    const handleResize = () => {
      const width = currentRef.clientWidth;
      const height = currentRef.clientHeight;

      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    // Añadir listener para el evento de redimensionamiento
    window.addEventListener('resize', handleResize);

    // Limpieza al desmontar el componente
    return () => {
      cancelAnimationFrame(frameId.current);
      currentRef.removeChild(renderer.domElement);
      window.removeEventListener('resize', handleResize);
      scene.clear();
    };
  }, []);

  // Renderizar el contenedor que mantendrá el canvas de Three.js
  return <div ref={ref} style={{ width: '100%', height: '100%' }} />;
}

export default TorusKnot;
</file>

<file path="src/components/Chat.js">
import React, { useState, useRef, useEffect } from 'react';
import io from 'socket.io-client';
// Conectarse al servidor de Socket.IO
const apiUrl = process.env.REACT_APP_API_URL;
const socket = io(apiUrl); // Asegúrate de que la URL coincida con tu servidor



const Message = ({ text, from }) => (
    <div>
        <strong>{from === 'user' ? 'Usuario' : 'AI'}:</strong> {text}
    </div>
);

// Estilos convertidos a formato de objeto JavaScript
const styles = {
    chatBox: {
        position: 'fixed',
        bottom: '10px',
        right: '10px',
        width: '300px',
        height: '400px',
        borderRadius: '15px',
        backgroundColor: '#f0f0f0',
        boxShadow: '0 4px 8px rgba(0,0,0,0.1)',
        overflow: 'hidden',
        zIndex: 1000,
        display: 'flex',
        flexDirection: 'column',
    },
    messageArea: {
        flexGrow: 1,
        overflowY: 'auto',
        padding: '10px',
        backgroundColor: '#fff',
        borderTop: '1px solid #ddd',
        borderBottom: '1px solid #ddd',
    },
    inputArea: {
        display: 'flex',
        padding: '10px',
        backgroundColor: '#f0f0f0',
    },
    messageInput: {
        flexGrow: 1,
        padding: '8px 12px',
        marginRight: '8px',
        border: '1px solid #ddd',
        borderRadius: '4px',
    },
    sendButton: {
        padding: '8px 12px',
        backgroundColor: '#007bff',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
    },
    toggleChat: (isChatVisible) => ({
        position: 'fixed',
        bottom: isChatVisible ? '400px' : '10px',
        right: '10px',
        backgroundColor: '#007bff',
        color: 'white',
        padding: '5px 10px',
        borderRadius: '10px',
        cursor: 'pointer',
        zIndex: 2001,
    }),
};

const Chat = () => {
    const [messages, setMessages] = useState([]);
    const [inputValue, setInputValue] = useState('');
    const [aiMessage, setAiMessage] = useState('');
    const [isChatVisible, setIsChatVisible] = useState(false);
    const messageAreaRef = useRef(null);

    useEffect(() => {
        socket.on('chat message', (msg) => {
            console.log("Entra en other");
            setMessages((prevMessages) => [...prevMessages, { text: msg, from: 'other' }]);
        });

        socket.on('chat response', (response) => {
            if (response.includes('/Fin')) {
                setMessages(prev => [...prev, { text: aiMessage + response.replace('/Fin', ''), from: 'AI' }]);
                setAiMessage('');
            } else {
                setAiMessage(prev => prev + response);
            }
        });

        return () => {
            socket.off('chat message');
            socket.off('chat response');
        };
    }, [aiMessage]);

    const sendMessage = () => {
        const trimmedInput = inputValue.trim();
        if (trimmedInput !== '') {
            setMessages((prevMessages) => [...prevMessages, { text: trimmedInput, from: 'user' }]);
            socket.emit('chat message', trimmedInput);
            setInputValue('');
        }
    };

    useEffect(() => {
        setTimeout(() => {
            if (messageAreaRef.current) {
                const { scrollHeight, clientHeight } = messageAreaRef.current;
                const maxScrollTop = scrollHeight - clientHeight;
                messageAreaRef.current.scrollTop = maxScrollTop > 0 ? maxScrollTop : 0;
            }
        }, 0);
    }, [messages, aiMessage]); // Incluye aiMessage en las dependencias
    

    const handleInputChange = (e) => setInputValue(e.target.value);

    const handleKeyPress = (e) => {
        if (e.key === 'Enter') sendMessage();
    };

    const toggleChat = () => setIsChatVisible(!isChatVisible);

    return (
        <div>
            <button onClick={toggleChat} style={styles.toggleChat(isChatVisible)}>
                {isChatVisible ? 'Ocultar Chat' : 'Mostrar Chat'}
            </button>
            {isChatVisible && (
                <div style={styles.chatBox}>
                    <div style={styles.messageArea} ref={messageAreaRef}>
                        {messages.map((msg, index) => (
                            <Message key={index} text={msg.text} from={msg.from} />
                        ))}
                        {/* Aquí se muestra el mensaje de la AI en construcción */}
                        {aiMessage && <Message text={aiMessage} from="AI" />}
                    </div>

                    <div style={styles.inputArea}>
                        <input
                            type="text"
                            value={inputValue}
                            onChange={handleInputChange}
                            onKeyPress={handleKeyPress}
                            placeholder="Escribe tu mensaje..."
                            style={styles.messageInput}
                        />
                        <button onClick={sendMessage} style={styles.sendButton}>
                            Enviar
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
};

export default Chat;
</file>

<file path="src/components/CursorFollower.js">
import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';

const CursorFollower = () => {
  const mountRef = useRef(null);

  useEffect(() => {
    const mount = mountRef.current;

    // Configuración básica de la escena
    const scene = new THREE.Scene();

    // Ajustar el campo de visión y la posición de la cámara
    const camera = new THREE.PerspectiveCamera(
      75,
      mount.clientWidth / mount.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 4
    ;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    mount.appendChild(renderer.domElement);

    // Cargar la textura para todas las caras
    const loader = new THREE.TextureLoader();
    const texture = loader.load('logo.png');

    const material = new THREE.MeshBasicMaterial({ map: texture });

    // Crear un cubo con la misma textura en todas las caras
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const cube = new THREE.Mesh(geometry, material);
    cube.scale.set(0.6, 0.6, 0.6);
    scene.add(cube);

    // Variables para la animación
    let targetY = 0;

    // Límites de movimiento del cubo en el eje Y
    let minY;
    let maxY;

    // Función para actualizar los límites según el tamaño de la ventana
    const updateLimits = () => {
      const fovInRadians = (camera.fov * Math.PI) / 180;
      const visibleHeight = 2 * Math.tan(fovInRadians / 2) * camera.position.z;
      minY = -visibleHeight / 2;
      maxY = visibleHeight / 2;
    };

    // Llamar a updateLimits inicialmente
    updateLimits();

    // Función para actualizar la posición objetivo del cubo según el cursor
    const onMouseMove = (event) => {
      const rect = mount.getBoundingClientRect();
      const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Mapeo de mouseY al rango de movimiento del cubo
      targetY = mouseY * (maxY - minY) / 2;
    };

    // Añadir el listener al evento de movimiento del mouse
    window.addEventListener('mousemove', onMouseMove);

    // Función de animación
    const animate = () => {
      requestAnimationFrame(animate);

      // Interpolación suave hacia la posición objetivo
      cube.position.y += (targetY - cube.position.y) * 0.1;

      // Rotación constante
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;

      renderer.render(scene, camera);
    };
    animate();

    // Manejo de redimensionamiento
    const handleResize = () => {
      const width = mount.clientWidth;
      const height = mount.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      // Recalcular los límites
      updateLimits();
    };
    window.addEventListener('resize', handleResize);

    // Limpieza al desmontar el componente
    return () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('resize', handleResize);
      mount.removeChild(renderer.domElement);
      renderer.dispose();

      // Liberar recursos
      material.dispose();
      texture.dispose();
      geometry.dispose();
    };
  }, []);

  return (
    <div
      ref={mountRef}
      style={{ width: '100%', height: '100%' }}
    />
  );
};

export default CursorFollower;
</file>

<file path="src/components/ErrorComponent.js">
import React from 'react';
import { useLocation } from 'react-router-dom';

function ErrorComponent({ errorCode: propErrorCode, errorMessage: propErrorMessage }) {
  const location = useLocation();
  const { errorCode: stateErrorCode, errorMessage: stateErrorMessage } = location.state || { errorCode: 'Unknown', errorMessage: 'An unknown error occurred.' };

  const errorCode = stateErrorCode || propErrorCode;
  const errorMessage = stateErrorMessage || propErrorMessage;

  return (
    <div style={{ color: 'red', textAlign: 'center', marginTop: '20px' }}>
      <h2>Error {errorCode}</h2>
      <p>{errorMessage}</p>
    </div>
  );
}

export default ErrorComponent;
</file>

<file path="src/components/GamePage.css">
.games-page {
    padding: 20px;
  }
  
  .games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 20px;
    margin-top: 20px;
  }
  
  .game-card {
    background-color: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 20px;
    text-align: center;
    text-decoration: none;
    color: #333;
    transition: box-shadow 0.3s ease;
  }
  
  .game-card:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
</file>

<file path="src/components/ProtectedRoute.js">
import React from 'react';
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const isAuthenticated = localStorage.getItem('auth-token'); // Asumiendo que guardas el token aquí
  return isAuthenticated ? children : <Navigate to="/login" />;
}
export default ProtectedRoute;
</file>

<file path="src/components/SideBarMenu.js">
import React from 'react';
import { Link } from 'react-router-dom';
import '../css/sidemenu.css';

const SidebarMenu = () => {
  return (
    <div className="sidebar-menu">
      <Link to="/games" className="games-button">Games</Link>
    </div>
  );
};

export default SidebarMenu;
</file>

<file path="src/css/blog-new.css">
.blog-main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    background: #fff;
  }
  
  .blog-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 3rem;
  }
  
  .blog-header h1 {
    font-size: 2.5rem;
    color: #1a1a1a;
    margin: 0;
  }
  
  .new-post-button {
    padding: 0.75rem 1.5rem;
    background: #0066cc;
    color: white;
    border-radius: 8px;
    text-decoration: none;
    transition: background 0.3s ease;
  }
  
  .new-post-button:hover {
    background: #0052a3;
  }
  
  .blog-posts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 2rem;
    margin-bottom: 3rem;
  }
  
  .post-card {
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease;
    background: white;
  }
  
  .post-card:hover {
    transform: translateY(-5px);
  }
  
  .post-image {
    position: relative;
    width: 100%;
    height: 250px; /* Aumentamos un poco la altura */
    overflow: hidden;
    background: #f5f5f5; /* Color de fondo por si la imagen no carga */
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .post-image img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* Mantiene la proporción y cubre todo el espacio */
    object-position: center; /* Centra la imagen */
  }
  
  .post-card:hover .post-image img {
    transform: scale(1.05);
  }
  
  .post-content {
    padding: 1.5rem;
  }
  
  .post-content h2 {
    font-size: 1.25rem;
    margin: 0 0 1rem;
    color: #1a1a1a;
  }
  
  .post-meta {
    display: flex;
    gap: 1rem;
    font-size: 0.875rem;
    color: #666;
    margin-bottom: 1rem;
  }
  
  .post-excerpt {
    color: #444;
    margin-bottom: 1.5rem;
    line-height: 1.6;
  }
  
  .post-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .read-more {
    color: #0066cc;
    text-decoration: none;
    font-weight: 500;
  }
  
  .admin-actions {
    display: flex;
    gap: 0.5rem;
  }
  
  .admin-actions button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  
  .admin-actions button:first-child {
    background: #4CAF50;
    color: white;
  }
  
  .admin-actions button:last-child {
    background: #f44336;
    color: white;
  }
  
  .pagination {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    margin-top: 2rem;
  }
  
  .page-button {
    padding: 0.5rem 1rem;
    border: 1px solid #ddd;
    background: white;
    border-radius: 6px;
    cursor: pointer;
  }
  
  .page-button.active {
    background: #0066cc;
    color: white;
    border-color: #0066cc;
  }
  
  @media (max-width: 768px) {
    .blog-posts-grid {
      grid-template-columns: 1fr;
    }
    
    .blog-header {
      flex-direction: column;
      gap: 1rem;
      text-align: center;
    }
  }
</file>

<file path="src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

import 'bootstrap/dist/css/bootstrap.min.css';
import 'bootstrap/dist/js/bootstrap.bundle.min.js';



const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/components/juegos/Cube.js">
import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';

// Definición de RenderPixelatedPass
class RenderPixelatedPass extends Pass {
  constructor(resolution, scene, camera) {
    super();
    this.resolution = new THREE.Vector2(resolution, resolution);
    this.scene = scene;
    this.camera = camera;
    
    this.renderTarget = new THREE.WebGLRenderTarget(resolution, resolution, {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      stencilBuffer: false
    });
    
    this.material = this.createMaterial();
    this.fsQuad = new FullScreenQuad(this.material);
  }

  render(renderer, writeBuffer, readBuffer) {
    const oldRenderTarget = renderer.getRenderTarget();

    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(oldRenderTarget);

    this.material.uniforms.tDiffuse.value = this.renderTarget.texture;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }

  createMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        resolution: {
          value: new THREE.Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec4 resolution;
        varying vec2 vUv;
        void main() {
          vec2 uv = vUv;
          vec4 texel = texture2D(tDiffuse, uv);
          gl_FragColor = texel;
        }
      `
    });
  }
}

// Definición de PixelatePass
class PixelatePass extends Pass {
  constructor(resolution) {
    super();
    this.resolution = new THREE.Vector2(resolution, resolution);
    this.fsQuad = new FullScreenQuad(this.createMaterial());
  }

  render(renderer, writeBuffer, readBuffer) {
    const uniforms = this.fsQuad.material.uniforms;
    uniforms.tDiffuse.value = readBuffer.texture;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }

  createMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        resolution: {
          value: new THREE.Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec4 resolution;
        varying vec2 vUv;
        void main() {
          vec2 uv = vUv;
          vec2 pixelatedUV = floor(uv * resolution.xy) / resolution.xy;
          gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
      `
    });
  }
}

function Cube() {
  const ref = useRef();
  const frameId = useRef();

  useEffect(() => {
    const currentRef = ref.current;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, currentRef.clientWidth / currentRef.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    renderer.setSize(currentRef.clientWidth, currentRef.clientHeight);
    currentRef.appendChild(renderer.domElement);

    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    camera.position.z = 5;

    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    // Setup EffectComposer
    const composer = new EffectComposer(renderer);
    
    // Add RenderPixelatedPass
    const renderPixelatedPass = new RenderPixelatedPass(256, scene, camera);
    composer.addPass(renderPixelatedPass);

    // Add PixelatePass
    const pixelatePass = new PixelatePass(256);
    composer.addPass(pixelatePass);

    const animate = () => {
      frameId.current = requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      composer.render();
    };

    animate();

    const handleResize = () => {
      const width = currentRef.clientWidth;
      const height = currentRef.clientHeight;
      renderer.setSize(width, height);
      composer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(frameId.current);
      currentRef.removeChild(renderer.domElement);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <div ref={ref} style={{ width: '100%', height: '400px' }}></div>;
}

export default Cube;
</file>

<file path="src/components/Footer.js">
import React from 'react';

function Footer() {
    return (
      <footer className="bg-light text-center" style={{ padding: '10px 0' }}>
        <p>&copy; {new Date().getFullYear()} Dante Collazzi. All rights reserved.</p>
      </footer>
    );
  }
  

export default Footer;
</file>

<file path="src/components/GamePlayer.js">
import React, { Suspense, lazy, useState, useEffect } from 'react';
import { useParams, Navigate, useLocation } from 'react-router-dom';
import gameRegistry from './GameRegistry';

const GamePlayer = () => {
  const { gameId } = useParams();
  const location = useLocation();
  const [roomId, setRoomId] = useState(null);

  // Extraer el parámetro room de la URL
  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const room = params.get('room') || 'sala1'; // Default to sala1 if not specified
    setRoomId(room);
  }, [location]);

  // Redireccionar si el juego no existe
  if (!gameRegistry[gameId]) {
    return <Navigate to="/games" replace />;
  }

  // Cargar el componente del juego de forma dinámica
  const Game = lazy(gameRegistry[gameId].path);

  // Mostrar un estado de carga mientras se determina el roomId
  if (!roomId) return <div>Loading...</div>;

  return (
    <div className="game-player">
      <Suspense fallback={<div>Loading game...</div>}>
        <Game roomId={roomId} />
      </Suspense>
    </div>
  );
};

export default GamePlayer;
</file>

<file path="src/css/blogpost.css">
/* Estilos básicos del blog */
.blog-post {
    max-width: 100%;
    word-wrap: break-word;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #2d3748;
}

/* Estilos para títulos */
.blog-title {
    font-size: 2.5em;
    font-weight: 800;
    color: #1a202c;
    margin-bottom: 0.5em;
    line-height: 1.2;
}

.blog-subtitle {
    font-size: 1.8em;
    font-weight: 700;
    color: #2d3748;
    margin: 1.5em 0 0.5em;
}

.blog-section {
    font-size: 1.4em;
    font-weight: 600;
    color: #4a5568;
    margin: 1.2em 0 0.4em;
}

/* Bloques especiales */
.blog-quote {
    border-left: 4px solid #4a5568;
    padding: 1em 2em;
    margin: 1.5em 0;
    background: #f7fafc;
    font-style: italic;
}

.blog-note {
    background: #ebf8ff;
    border: 1px solid #90cdf4;
    border-radius: 8px;
    padding: 1em;
    margin: 1em 0;
}

.blog-alert {
    background: #fff5f5;
    border: 1px solid #feb2b2;
    border-radius: 8px;
    padding: 1em;
    margin: 1em 0;
    color: #c53030;
}

/* Elementos inline */
.highlight {
    background: #fef3c7;
    padding: 0.2em 0.4em;
    border-radius: 4px;
}

.underline-text {
    border-bottom: 2px solid #4a5568;
}

/* Meta información */
.blog-meta {
    color: #718096;
    font-size: 0.9em;
    margin-bottom: 2em;
}

/* Imágenes */
.blog-post img {
    max-width: 100%;
    height: auto;
}

.featured-image {
    width: 100%;
    height: auto;
    border-radius: 8px;
    margin: 1em 0;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* Review específicos */
.game-meta {
    background: #f7fafc;
    padding: 1em;
    border-radius: 8px;
    margin: 1em 0;
}

/* Tutorial específicos */
.tutorial-meta {
    background: #f0fff4;
    padding: 1em;
    border-radius: 8px;
    margin: 1em 0;
}

/* Contenedores */
.content-part {
    margin-bottom: 1rem;
}

.game-container {
    max-width: 100%;
    overflow-x: auto;
    margin: 1.5em 0;
}

/* Contenedores multimedia */
.video-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
    margin: 1em 0;
}

.video-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.audio-container {
    margin: 1em 0;
    padding: 1em;
    background: #f7fafc;
    border-radius: 8px;
}

.audio-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5em;
}

.audio-title {
    font-weight: bold;
    color: #2d3748;
}

/* Estilos del bloque de código */
.code-block {
    position: relative;
    margin: 1.5em 0;
    background: #282c34;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: #21252b;
    border-bottom: 1px solid #373b41;
}

.code-language {
    color: #abb2bf;
    font-weight: 600;
    text-transform: uppercase;
}

/* Botón de copiar código */
.copy-button {
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    background-color: #0d6efd;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 1;
    opacity: 0.8;
}

.copy-button::before {
    content: '📄';
    font-size: 1rem;
}

.copy-button:hover {
    background-color: #0b5ed7;
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    opacity: 1;
}

.copy-button:active {
    transform: translateY(0);
    box-shadow: none;
}

.copy-button.copied {
    background-color: #28a745;
    animation: bounce 0.5s ease;
}

.copy-button.copied::before {
    content: '✅';
}

.copy-button.copied::after {
    content: 'Copied!';
    margin-left: 8px;
}

/* Animación para el botón de copiar */
@keyframes bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-5px);
    }
}

/* Estilos de código y sintaxis */
.code-block pre {
    margin: 0;
    padding: 16px;
    background: #282c34;
    overflow-x: auto;
    tab-size: 4;
}

.code-block code {
    font-family: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace;
    font-size: 0.9em;
    line-height: 1.5;
    color: #abb2bf;
}

/* Tokens de sintaxis */
.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: #8292a2;
    font-style: italic;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
    color: #f92672;
}

.token.boolean,
.token.number {
    color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #a6e22e;
}

/* Responsive */
@media (max-width: 768px) {
    .blog-post h1 {
        font-size: 1.5rem;
    }

    .blog-title {
        font-size: 2em;
    }

    .blog-subtitle {
        font-size: 1.5em;
    }

    .blog-section {
        font-size: 1.2em;
    }

    .blog-quote {
        padding: 0.8em 1.5em;
    }

    .code-block pre {
        padding: 12px;
    }
}

@media (max-width: 576px) {
    .container-fluid {
        padding-left: 10px;
        padding-right: 10px;
    }

    .blog-quote {
        padding: 0.6em 1.2em;
    }
    
    .copy-button {
        padding: 6px 12px;
        font-size: 0.8rem;
    }
}
</file>

<file path="src/css/editor.css">
/* Tokens del editor */
.game-token {
  background-color: #e0e0e0;
  color: #333;
  padding: 2px 5px;
  border-radius: 5px;
  font-weight: bold;
  margin: 0 2px;
}

/* Contenedor de video */
.video-container {
  position: relative;
  padding-bottom: 56.25%;
  height: 0;
  overflow: hidden;
  margin: 1.5em 0;
  border-radius: 8px;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.video-container iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 8px;
}

/* Contenedor principal del editor */
.editor-container {
  max-width: 1200px;
  margin: 40px auto;
  padding: 20px;
  background-color: #ffffff;
  border-radius: 8px;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.editor-form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.form-group {
  margin-bottom: 20px;
}

.form-control {
  width: 100%;
  padding: 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
  transition: all 0.3s ease;
  background-color: #fff;
}

.form-control:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-control.error {
  border-color: #ef4444;
  background-color: #fff5f5;
}

/* Sistema de alertas */
.alert {
  padding: 12px 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  animation: slideIn 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

@keyframes slideIn {
  from {
    transform: translateY(-20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.alert-success {
  background-color: #dcfce7;
  color: #166534;
  border: 1px solid #16a34a;
}

.alert-error {
  background-color: #fee2e2;
  color: #991b1b;
  border: 1px solid #ef4444;
}

.alert-close {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  padding: 0 5px;
  color: inherit;
  transition: opacity 0.2s ease;
}

.alert-close:hover {
  opacity: 0.7;
}

/* Subida de imágenes */
.image-upload-container {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 10px;
  border: 2px dashed #ddd;
  border-radius: 8px;
  transition: all 0.3s ease;
}

.image-upload-container:hover {
  border-color: #3b82f6;
  background-color: rgba(59, 130, 246, 0.05);
}

.image-preview {
  width: 100px;
  height: 100px;
  object-fit: cover;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Mensajes de error */
.error-message {
  color: #ef4444;
  font-size: 14px;
  margin-top: 4px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.error-message::before {
  content: '⚠️';
}

/* Botón de envío */
.submit-button {
  padding: 12px 24px;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
}

.submit-button:hover:not(:disabled) {
  background-color: #2563eb;
  transform: translateY(-1px);
  box-shadow: 0 4px 6px rgba(59, 130, 246, 0.4);
}

.submit-button:active:not(:disabled) {
  transform: translateY(0);
}

.submit-button:disabled {
  background-color: #94a3b8;
  cursor: not-allowed;
  box-shadow: none;
}

.submit-button.submitting {
  opacity: 0.7;
  pointer-events: none;
}

/* Bloques de código */
.code-block {
  margin: 1.5em 0;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  background: #282c34;
}

.code-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background: #21252b;
  border-bottom: 1px solid #373b41;
}

.code-language {
  font-weight: 600;
  color: #abb2bf;
  text-transform: uppercase;
  font-size: 0.875rem;
  letter-spacing: 0.05em;
}

.copy-button {
  padding: 6px 12px;
  background: #323842;
  color: #abb2bf;
  border: 1px solid #373b41;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.875rem;
  transition: all 0.2s ease;
}

.copy-button:hover {
  background: #3e4451;
  color: #ffffff;
}

.copy-button:active {
  transform: scale(0.95);
}

/* Modal para ingresar código */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 90%;
  max-width: 600px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.modal-content h3 {
  margin: 0;
  color: #1f2937;
}

.language-select {
  padding: 8px;
  border-radius: 4px;
  border: 1px solid #ddd;
  font-size: 14px;
}

.code-input {
  width: 100%;
  height: 200px;
  font-family: 'Fira Code', monospace;
  padding: 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  resize: vertical;
  background: #282c34;
  color: #abb2bf;
  font-size: 14px;
  line-height: 1.5;
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

.modal-buttons button {
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
}

.modal-buttons .submit-btn {
  background: #3b82f6;
  color: white;
}

.modal-buttons .submit-btn:hover {
  background: #2563eb;
}

.modal-buttons .cancel-btn {
  background: #e5e7eb;
  color: #374151;
}

.modal-buttons .cancel-btn:hover {
  background: #d1d5db;
}

/* Estilos de código y sintaxis */
pre {
  margin: 0;
  padding: 16px;
  overflow-x: auto;
  background: #282c34;
}

code {
  font-family: 'Fira Code', 'JetBrains Mono', 'Cascadia Code', Consolas, monospace;
  font-size: 0.875rem;
  line-height: 1.6;
  color: #abb2bf;
}

/* Colores de sintaxis */
.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #7f848e;
  font-style: italic;
}

.token.function {
  color: #61afef;
}

.token.keyword {
  color: #c678dd;
}

.token.string {
  color: #98c379;
}

.token.number {
  color: #d19a66;
}

.token.operator {
  color: #56b6c2;
}

.token.class-name {
  color: #e5c07b;
}

/* Personalizaciones del editor TinyMCE */
.tox-tinymce {
  border-radius: 8px !important;
  border-color: #ddd !important;
}

.tox .tox-toolbar__primary {
  background: #f8fafc !important;
  border-bottom: 1px solid #ddd !important;
}

.tox .tox-tbtn {
  border-radius: 4px !important;
}

.tox .tox-tbtn:hover {
  background: #f1f5f9 !important;
}

/* Diseño responsivo */
@media (max-width: 768px) {
  .editor-container {
    margin: 20px auto;
    padding: 15px;
  }
  
  .image-upload-container {
    flex-direction: column;
    align-items: flex-start;
  }

  .form-control,
  .submit-button {
    font-size: 14px;
    padding: 10px 20px;
  }

  .code-header {
    flex-direction: column;
    gap: 8px;
  }
  
  .code-language {
    font-size: 0.75rem;
  }
  
  .copy-button {
    width: 100%;
    text-align: center;
  }

  .modal-content {
    width: 95%;
    padding: 16px;
  }

  .code-input {
    height: 150px;
  }
}

@media (max-width: 480px) {
  .editor-container {
    margin: 10px;
    padding: 10px;
  }
  
  pre {
    padding: 12px;
    font-size: 12px;
  }
}

.code-block pre {
  position: relative;
  margin-top: 0;
}

.toolbar-item {
  position: absolute;
  top: -40px;
  right: 10px;
}

.code-block {
  padding-top: 40px;
  position: relative;
}

/* Contenedor de audio */
.audio-container {
  margin: 1.5em 0;
  padding: 1em;
  background: #f3f4f6;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.audio-title {
  margin-bottom: 0.5em;
  font-weight: 600;
  color: #374151;
  font-size: 0.9em;
}

.audio-container audio {
  width: 100%;
  border-radius: 4px;
}

/* Personalización del reproductor de audio */
.audio-container audio::-webkit-media-controls-panel {
  background-color: #ffffff;
}

.audio-container audio::-webkit-media-controls-play-button {
  background-color: #3b82f6;
  border-radius: 50%;
}

.audio-container audio::-webkit-media-controls-timeline {
  background-color: #e5e7eb;
  border-radius: 2px;
  height: 4px;
}
</file>

<file path="src/css/header.css">
.logo-link {
  display: flex;
  align-items: center;
  text-decoration: none;
  margin-left: 15px;
}

.logo-container {
  width: 60px;
  height: 60px;
  overflow: hidden;
  border-radius: 50%;
  border: 2px solid #1a1a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: white;
  transition: all 0.3s ease;
}

.circular-logo {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.nav-welcome-container {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-left: auto;
  padding-right: 20px;
}

nav {
  display: flex;
  gap: 20px;
}

.nav-link {
  color: #1a1a1a;
  text-decoration: none;
  font-size: 1rem;
  transition: all 0.3s ease;
  padding: 10px 15px;
  border-radius: 5px;
  position: relative;
}

.nav-link::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 2px;
  bottom: 0;
  left: 0;
  background-color: #1a1a1a;
  transform: scaleX(0);
  transition: transform 0.3s ease;
}

.nav-link:hover::after,
.nav-link.active::after {
  transform: scaleX(1);
}

.nav-link:hover,
.nav-link:focus {
  background-color: rgba(26, 26, 26, 0.1);
}

.nav-link.active {
  font-weight: bold;
}

.welcome-message {
  font-size: 0.9rem;
  color: #1a1a1a;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 200px;
}

@media (max-width: 768px) {
  .logo-link {
    margin-left: 10px;  /* Margen más pequeño en móvil */
  }

  header {
    height: auto;
    padding: 10px;
  }

  .container {
    flex-direction: column;
    align-items: flex-start;
  }

  .nav-welcome-container {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
    margin-top: 10px;
    padding-right: 10px;
  }

  nav {
    flex-wrap: wrap;
  }

  .welcome-message {
    margin-top: 5px;
  }
}
</file>

<file path="src/css/sidemenu.css">
.sidebar-menu {
    width: 60px; /* Reducido de 100px */
    height: 100vh;
    position: fixed;
    top: 80px;
    right: 0;
    background-color: #f8f9fa;
    padding: 10px;
    box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    z-index: 100;
}
  
.games-button {
    padding: 10px;
    background-color: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 5px;
    transition: background-color 0.3s ease;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    transform: rotate(180deg);
}
  
.games-button:hover {
    background-color: #0056b3;
}
</file>

<file path="src/App.css">
/* App.css */
.main-content {
  padding-top: 80px; /* Solo mantenemos el padding superior para el header */
  width: 100%;
  overflow-x: hidden;
}

/* Ajustes para páginas específicas */
.blog-container,
.about-container,
.games-page {
  padding-top: 20px;
}

html, body, #root {
  height: 100%;
  margin: 0;
  padding: 0;
  max-width: 100%;
  overflow-x: hidden;
}
</file>

<file path="src/components/Blog.js">
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import '../css/blog-new.css';

function Blog() {
 const [blogPosts, setBlogPosts] = useState([]);
 const [currentPage, setCurrentPage] = useState(1);
 const [totalPages, setTotalPages] = useState(0);
 const isAdmin = localStorage.getItem('userRole') === 'admin';
 const navigate = useNavigate();

 const apiUrl = process.env.REACT_APP_API_URL;

 useEffect(() => {
   fetch(`${apiUrl}/api/posts?page=${currentPage}`)
     .then(response => response.json())
     .then(data => {
       setBlogPosts(data.posts || []);
       setTotalPages(data.totalPages || 0);
     })
     .catch(error => console.error('Error:', error));
 }, [currentPage, apiUrl]);

 const handlePageChange = (newPage) => {
   setCurrentPage(newPage);
 };

 const handleDelete = (postId) => {
   const confirmDelete = window.confirm('¿Estás seguro de que deseas eliminar este post?');
   if (confirmDelete) {
     fetch(`${apiUrl}/api/posts/${postId}`, {
       method: 'DELETE',
       headers: {
         'Content-Type': 'application/json',
         'Authorization': `Bearer ${localStorage.getItem('auth-token')}`
       }
     })
       .then(response => {
         if (!response.ok) {
           throw new Error('Error al eliminar el post');
         }
         return response.json();
       })
       .then(() => {
         setBlogPosts(blogPosts.filter(post => post.id !== postId));
       })
       .catch(error => console.error('Error:', error));
   }
 };

 const handleEdit = (postId) => {
   navigate(`/edit-post/${postId}`);
 };

 return (
   <div className="blog-main">
     <div className="blog-header">
       <h1>Latest Posts</h1>
       {isAdmin && (
         <Link to="/new-post" className="new-post-button">
           Write New Post
         </Link>
       )}
     </div>
     
     <div className="blog-posts-grid">
       {blogPosts.map(post => (
         <article key={post.id} className="post-card">
           <div className="post-image">
             {post.imageUrl && (
               <img src={post.imageUrl} alt={post.title} />
             )}
           </div>
           <div className="post-content">
             <h2>{post.title}</h2>
             <div className="post-meta">
               <span className="author">{post.author}</span>
               <span className="date">
                 {new Date(post.fechaCreacion).toLocaleDateString()}
               </span>
             </div>
             <div className="post-excerpt" 
               dangerouslySetInnerHTML={{ 
                 __html: post.content.substring(0, 150) + '...' 
               }}>
             </div>
             <div className="post-actions">
               <Link to={`/blog/${post.id}`} className="read-more">
                 Read More →
               </Link>
               {isAdmin && (
                 <div className="admin-actions">
                   <button onClick={() => handleEdit(post.id)}>Edit</button>
                   <button onClick={() => handleDelete(post.id)}>Delete</button>
                 </div>
               )}
             </div>
           </div>
         </article>
       ))}
     </div>

     <div className="pagination">
       {[...Array(totalPages)].map((_, index) => (
         <button
           key={index}
           onClick={() => handlePageChange(index + 1)}
           className={`page-button ${index + 1 === currentPage ? 'active' : ''}`}
         >
           {index + 1}
         </button>
       ))}
     </div>
   </div>
 );
}

export default Blog;
</file>

<file path="src/components/BlogPost.js">
import React, { useState, useEffect, Suspense } from 'react';
import { useParams } from 'react-router-dom';
import gameRegistry from './GameRegistry';
import Prism from 'prismjs';
import 'prismjs/themes/prism-okaidia.css';

import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-tsx';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';
import '../css/blogpost.css';

function BlogPost() {
    const { id } = useParams();
    const [post, setPost] = useState(null);
    const apiUrl = process.env.REACT_APP_API_URL;

    useEffect(() => {
        fetch(`${apiUrl}/api/posts/${id}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                setPost(data);
                // Inicializar Prism después de que el contenido se cargue
                setTimeout(() => {
                    Prism.highlightAll();
                }, 0);
            })
            .catch(error => console.error('Error fetching data:', error));
    }, [id, apiUrl]);

    // Efecto adicional para reinicializar Prism cuando el contenido cambie
    useEffect(() => {
        if (post) {
            Prism.highlightAll();
        }
    }, [post]);

    useEffect(() => {
        window.copyCode = (elementId) => {
            const pre = document.getElementById(elementId);
            if (!pre) return;
            
            const code = pre.querySelector('code');
            const text = code ? code.textContent : pre.textContent;
            
            navigator.clipboard.writeText(text)
              .then(() => {
                const button = pre.parentElement.querySelector('.copy-button');
                if (button) {
                  button.textContent = 'Copied!';
                  setTimeout(() => {
                    button.textContent = 'Copy';
                  }, 2000);
                }
              });
          };
      }, []);

    const renderPostContent = (content) => {
        const contentParts = content.split(/\{\{\{Juego:(\w+)\}\}\}/g);

        return contentParts.map((part, index) => {
            if (gameRegistry[part] && gameRegistry[part].path) {
                const GameComponent = React.lazy(gameRegistry[part].path);
                return (
                    <Suspense key={index} fallback={<div>Loading...</div>}>
                        <div className="game-container my-4">
                            <GameComponent />
                        </div>
                    </Suspense>
                );
            } else {
                return (
                    <div
                        key={index}
                        className="content-part"
                        dangerouslySetInnerHTML={{
                            __html: part.replace(/<img /g, '<img class="img-fluid" ')
                        }}
                    />
                );
            }
        });
    };

    if (!post) {
        return <div className="text-center py-5">Cargando...</div>;
    }

    return (
        <div className="container-fluid py-3 py-md-5 blog-post-container">
            <div className="row justify-content-center">
                <div className="col-12 col-md-10 col-lg-8">
                    <article className="blog-post">
                        <h1 className="mb-3 mb-md-4">{post.title}</h1>
                        {post.imageUrl && (
                            <img
                                src={post.imageUrl}
                                alt={post.title}
                                className="img-fluid rounded mb-3 mb-md-4"
                            />
                        )}
                        <p className="text-muted small">
                            <span className="d-block d-md-inline">Autor: {post.author}</span>
                            <span className="d-none d-md-inline"> | </span>
                            <span className="d-block d-md-inline">
                                Publicado: {post.fechaCreacion && new Date(post.fechaCreacion).toLocaleString()}
                            </span>
                        </p>
                        <div className="post-content">
                            {renderPostContent(post.content)}
                        </div>
                    </article>
                </div>
            </div>
        </div>
    );
}

export default BlogPost;
</file>

<file path="src/components/Contact.js">
import React, { useState } from 'react';
import { FaGithub, FaTwitter, FaLinkedin, FaEnvelope, FaArrowRight } from 'react-icons/fa';
import '../css/contact.css';

function Contact() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');
  const [status, setStatus] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setStatus('Sending...');

    try {
      // Simulación de espera para demo
      await new Promise(resolve => setTimeout(resolve, 1500));

      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/contact`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name, email, message }),
      });

      if (response.ok) {
        setStatus('Message sent successfully! Thanks for reaching out.');
        setName('');
        setEmail('');
        setMessage('');
      } else {
        const errorData = await response.json().catch(() => ({}));
        setStatus(`Error: ${errorData.message || 'Could not send message. Please try again or use another method.'}`);
      }
    } catch (error) {
      console.error('Error submitting contact form:', error);
      setStatus('Error sending message. Please check your connection or try again later.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="contact-page-container">
      <h2 className="contact-title section-title">Get In Touch</h2>

      <p className="contact-intro">
        I'm always open to discussing new projects, creative ideas or opportunities to be part of your visions.
        Feel free to reach out using the form below or through my social channels.
      </p>

      <div className="contact-content-wrapper">
        <div className="contact-form-container">
          <form onSubmit={handleSubmit} className="contact-form">
            <div className="form-group">
              <label htmlFor="name">Name</label>
              <input
                type="text"
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Your Name"
                required
                disabled={isLoading}
              />
            </div>
            <div className="form-group">
              <label htmlFor="email">Email</label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="example@gmail.com"
                required
                disabled={isLoading}
              />
            </div>
            <div className="form-group">
              <label htmlFor="message">Message</label>
              <textarea
                id="message"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="Your message here..."
                required
                disabled={isLoading}
              ></textarea>
            </div>
            <button type="submit" className="submit-button" disabled={isLoading}>
              {isLoading ? 'Sending...' : 'Send Message'}
              {!isLoading && <FaArrowRight style={{ marginLeft: '10px' }} />}
            </button>
          </form>
          {status && (
            <p className={`status-message ${status.startsWith('Error') ? 'error' : 'success'}`}>
              {status}
            </p>
          )}
        </div>

        <div className="contact-alternatives">
          <h3>Other ways to connect:</h3>
          <div className="social-links-contact">
            <a href="https://github.com/PitiGo" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
              <FaGithub /> <span>GitHub</span>
            </a>
            <a href="https://x.com/DAcerbus" target="_blank" rel="noopener noreferrer" aria-label="Twitter">
              <FaTwitter /> <span>Twitter</span>
            </a>
            <a href="https://www.linkedin.com/in/dantecollazzi/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
              <FaLinkedin /> <span>LinkedIn</span>
            </a>

          </div>
        </div>
      </div>
    </div>
  );
}

export default Contact;
</file>

<file path="src/components/EditPost.js">
import React, { useState, useEffect, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Editor } from '@tinymce/tinymce-react';
import Prism from 'prismjs';
import 'prismjs/themes/prism-okaidia.css';
import 'prismjs/plugins/toolbar/prism-toolbar';
import 'prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard';

// Importar lenguajes adicionales de Prism
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-tsx';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';

// Componente Modal para ingresar código
const CodeInputModal = ({ isOpen, onClose, onSubmit }) => {
  const [code, setCode] = useState('');
  const [language, setLanguage] = useState('javascript');

  const languages = [
    'javascript', 'python', 'java', 'html', 'css',
    'typescript', 'jsx', 'tsx', 'sql', 'json', 'bash'
  ];

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(code, language);
    setCode('');
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
      <div className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4">
        <h3 className="text-xl font-semibold mb-4">Insertar Código</h3>
        <select
          value={language}
          onChange={(e) => setLanguage(e.target.value)}
          className="w-full mb-4 p-2 border border-gray-300 rounded-md"
        >
          {languages.map(lang => (
            <option key={lang} value={lang}>{lang}</option>
          ))}
        </select>
        <textarea
          value={code}
          onChange={(e) => setCode(e.target.value)}
          placeholder="Pega tu código aquí..."
          className="w-full h-64 p-3 border border-gray-300 rounded-md font-mono text-sm mb-4"
          autoFocus
        />
        <div className="flex justify-end space-x-3">
          <button
            onClick={handleSubmit}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Insertar
          </button>
          <button
            onClick={onClose}
            className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-100"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>
  );
};

// Componente Alert
const Alert = ({ message, type, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(onClose, 5000);
    return () => clearTimeout(timer);
  }, [onClose]);

  const bgColor = type === 'success' ? 'bg-green-100' : type === 'error' ? 'bg-red-100' : 'bg-blue-100';
  const textColor = type === 'success' ? 'text-green-800' : type === 'error' ? 'text-red-800' : 'text-blue-800';
  const borderColor = type === 'success' ? 'border-green-200' : type === 'error' ? 'border-red-200' : 'border-blue-200';

  return (
    <div className={`fixed top-4 right-4 z-50 p-4 rounded-lg border ${bgColor} ${borderColor} flex items-center`}>
      <span className={`${textColor} font-medium`}>{message}</span>
      <button
        onClick={onClose}
        className={`ml-4 ${textColor} hover:opacity-75`}
      >
        ×
      </button>
    </div>
  );
};

function EditPost() {
  const { id } = useParams();
  const navigate = useNavigate();
  const editorRef = useRef(null);
  const apiUrl = process.env.REACT_APP_API_URL;

  const [post, setPost] = useState(null);
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [image, setImage] = useState(null);
  const [imagePreview, setImagePreview] = useState('');
  const [isCodeModalOpen, setIsCodeModalOpen] = useState(false);
  const [alert, setAlert] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    const fetchPost = async () => {
      try {
        const response = await fetch(`${apiUrl}/api/posts/${id}`);
        if (!response.ok) throw new Error('Error al cargar el post');

        const data = await response.json();
        setPost(data);
        setTitle(data.title);
        setContent(data.content);
        if (data.imageUrl) setImagePreview(data.imageUrl);
      } catch (error) {
        console.error('Error:', error);
        setAlert({
          type: 'error',
          message: 'Error al cargar el post'
        });
      }
    };

    fetchPost();
  }, [id, apiUrl]);

  const handleImageChange = (event) => {
    const file = event.target.files[0];
    if (file) {
      setImage(file);
      setImagePreview(URL.createObjectURL(file));
    }
  };

  const handleYouTubeEmbed = () => {
    const youtubeUrl = prompt("Por favor, ingresa la URL del video de YouTube:");
    if (!youtubeUrl) return;

    const videoId = extractYouTubeId(youtubeUrl);
    if (videoId) {
      const embedCode = `
        <div class="video-container">
          <iframe
            width="560"
            height="315"
            src="https://www.youtube.com/embed/${videoId}"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen
          ></iframe>
        </div>
      `;
      editorRef.current?.insertContent(embedCode);
    } else {
      setAlert({
        type: 'error',
        message: 'URL de YouTube no válida'
      });
    }
  };

  const handleAudioUpload = async () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.mp3,.wav,.ogg,.aac,.m4a,.webm';
    input.multiple = true;

    input.onchange = async (e) => {
      const files = Array.from(e.target.files);

      for (const file of files) {
        const formData = new FormData();
        formData.append('audio', file);

        try {
          setAlert({
            type: 'info',
            message: `Subiendo ${file.name}...`
          });

          const response = await fetch(`${apiUrl}/api/upload-audio`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('auth-token')}`
            },
            body: formData
          });

          if (!response.ok) throw new Error('Error al subir el audio');

          const data = await response.json();
          const fileName = data.audioUrl.split('/').pop();

          const audioHtml = `
            <div class="audio-container" data-audio-file="${fileName}">
              <div class="audio-header">
                <div class="audio-title">${file.name}</div>
                <button type="button" class="delete-audio-btn" onclick="window.handleAudioDelete('${fileName}')">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18"></path>
                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                  </svg>
                </button>
              </div>
              <audio controls>
                <source src="${data.audioUrl}" type="${file.type}">
                Your browser does not support the audio element.
              </audio>
            </div>
          `;
          editorRef.current?.insertContent(audioHtml);

          setAlert({
            type: 'success',
            message: `${file.name} subido exitosamente!`
          });
        } catch (error) {
          console.error('Error:', error);
          setAlert({
            type: 'error',
            message: `Error al subir ${file.name}`
          });
        }
      }
    };
    input.click();
  };

  const handleCodeSubmit = (code, language) => {
    if (code) {
      const codeBlockId = `code-block-${Date.now()}`;
      const preElement = document.createElement('pre');
      const codeElement = document.createElement('code');

      preElement.id = codeBlockId;
      preElement.className = `language-${language}`;
      codeElement.className = `language-${language}`;
      codeElement.textContent = code;
      preElement.appendChild(codeElement);

      Prism.plugins.toolbar.registerButton('copy-to-clipboard', {
        text: 'Copy',
        onClick: function () {
          navigator.clipboard.writeText(code).then(() => {
            const copyButton = document.querySelector(`#${codeBlockId} .copy-to-clipboard`);
            copyButton.textContent = 'Copied!';
            setTimeout(() => copyButton.textContent = 'Copy', 2000);
          });
        }
      });

      editorRef.current?.insertContent(preElement.outerHTML);
      Prism.highlightElement(preElement);
    }
  };

  const extractYouTubeId = (url) => {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    setIsSubmitting(true);

    const formData = new FormData();
    formData.append('title', title);
    formData.append('content', editorRef.current.getContent());
    if (image) formData.append('image', image);

    try {
      const response = await fetch(`${apiUrl}/api/posts/${id}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth-token')}`,
        },
        body: formData
      });

      if (!response.ok) throw new Error('Error al actualizar el post');

      setAlert({
        type: 'success',
        message: '¡Post actualizado exitosamente!'
      });

      setTimeout(() => navigate(`/blog/${id}`), 1500);
    } catch (error) {
      console.error('Error:', error);
      setAlert({
        type: 'error',
        message: 'Error al actualizar el post'
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleLinkInsert = () => {
    const linkUrl = prompt("Por favor, ingresa la URL del enlace:");
    const linkText = prompt("Por favor, ingresa el texto para mostrar:");
    if (linkUrl && linkText) {
      const linkHtml = `<a href="${linkUrl}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
      editorRef.current?.insertContent(linkHtml);
    }
  };


  if (!post) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto px-4 py-8">
      {alert && (
        <Alert
          message={alert.message}
          type={alert.type}
          onClose={() => setAlert(null)}
        />
      )}

      <form onSubmit={handleSubmit} className="space-y-6">
        <div className="bg-white rounded-lg shadow-sm p-6 space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Título del Post
            </label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Escribe un título atractivo..."
              className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Imagen Destacada
            </label>
            <div className="flex items-center space-x-4">
              <input
                type="file"
                onChange={handleImageChange}
                accept="image/*"
                className="hidden"
                id="image-upload"
              />
              <label
                htmlFor="image-upload"
                className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 cursor-pointer"
              >
                Seleccionar Imagen
              </label>
              {imagePreview && (
                <img
                  src={imagePreview}
                  alt="Preview"
                  className="h-20 w-20 object-cover rounded-md"
                />
              )}
            </div>
          </div>
        </div>

        <Editor
          onInit={(evt, editor) => editorRef.current = editor}
          apiKey='d2cmewtag6kjp2p8p17tsmvvvqjqxaqifks441d9txizwi3g'
          initialValue={content}
          init={{
            height: 600,
            menubar: false,
            plugins: [
              'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
              'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
              'insertdatetime', 'media', 'table', 'help', 'wordcount', 'emoticons',
              'visualchars', 'quickbars', 'pagebreak', 'nonbreaking', 'template'
            ],

            toolbar1: 'styles | fontfamily fontsize | forecolor backcolor | template',
            toolbar2: 'bold italic underline strikethrough | alignleft aligncenter alignright alignjustify | bullist numlist | outdent indent',
            toolbar3: 'removeformat | table image media | link customlink youtube | emoticons insertcode audio pagebreak | code fullscreen help',

            style_formats: [
              {
                title: 'Encabezados', items: [
                  { title: 'Título principal', block: 'h1', classes: 'blog-title' },
                  { title: 'Subtítulo', block: 'h2', classes: 'blog-subtitle' },
                  { title: 'Sección', block: 'h3', classes: 'blog-section' }
                ]
              },
              {
                title: 'Bloques', items: [
                  { title: 'Cita destacada', block: 'blockquote', classes: 'blog-quote' },
                  { title: 'Nota al margen', block: 'div', classes: 'blog-note' },
                  { title: 'Caja de alerta', block: 'div', classes: 'blog-alert' }
                ]
              },
              {
                title: 'Inline', items: [
                  { title: 'Texto destacado', inline: 'span', classes: 'highlight' },
                  { title: 'Código inline', inline: 'code' },
                  { title: 'Texto subrayado', inline: 'span', classes: 'underline-text' }
                ]
              }
            ],

            templates: [
              {
                id: 'blog-article',
                name: 'Artículo de Blog',
                description: 'Estructura básica para un artículo',
                content: `
                  <h1 class="blog-title">Título del Artículo</h1>
                  <p class="blog-meta">Por [Autor] | [Fecha]</p>
                  <img src="placeholder.jpg" alt="Imagen destacada" class="featured-image"/>
                  <h2 class="blog-subtitle">Introducción</h2>
                  <p>Tu introducción aquí...</p>
                  <h2 class="blog-subtitle">Desarrollo</h2>
                  <p>Contenido principal...</p>
                  <h2 class="blog-subtitle">Conclusión</h2>
                  <p>Tus conclusiones aquí...</p>
                `
              },
              {
                id: 'game-review',
                title: 'Review de Juego',
                description: 'Plantilla para reviews de juegos',
                content: `
                  <h1 class="blog-title">Review: [Nombre del Juego]</h1>
                  <div class="game-meta">
                    <p><strong>Género:</strong> [Género]</p>
                    <p><strong>Plataforma:</strong> [Plataforma]</p>
                    <p><strong>Puntuación:</strong> ⭐⭐⭐⭐☆</p>
                  </div>
                  <h2>Resumen</h2>
                  <p>Resumen breve del juego...</p>
                  <h2>Gráficos y Sonido</h2>
                  <p>Análisis de los aspectos técnicos...</p>
                  <h2>Jugabilidad</h2>
                  <p>Descripción de la mecánica del juego...</p>
                  <h2>Conclusión</h2>
                  <p>Veredicto final...</p>
                `
              },
              {
                id: 'technical-tutorial',
                title: 'Tutorial Técnico',
                description: 'Estructura para tutoriales',
                content: `
                  <h1 class="blog-title">Tutorial: [Título]</h1>
                  <div class="tutorial-meta">
                    <p><strong>Nivel:</strong> [Principiante/Intermedio/Avanzado]</p>
                    <p><strong>Tiempo estimado:</strong> [X minutos]</p>
                  </div>
                  <h2>Requisitos Previos</h2>
                  <ul>
                    <li>Requisito 1</li>
                    <li>Requisito 2</li>
                  </ul>
                  <h2>Paso 1: [Título del Paso]</h2>
                  <p>Instrucciones detalladas...</p>
                  <h2>Paso 2: [Título del Paso]</h2>
                  <p>Instrucciones detalladas...</p>
                  <h2>Conclusión</h2>
                  <p>Resumen y siguientes pasos...</p>
                `
              }
            ],

            content_style: `
              body { 
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                font-size: 16px;
                line-height: 1.6;
                color: #2d3748;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
              }
              
              /* Estilos para títulos */
              .blog-title {
                font-size: 2.5em;
                font-weight: 800;
                color: #1a202c;
                margin-bottom: 0.5em;
                line-height: 1.2;
              }
              
              .blog-subtitle {
                font-size: 1.8em;
                font-weight: 700;
                color: #2d3748;
                margin: 1.5em 0 0.5em;
              }
              
              .blog-section {
                font-size: 1.4em;
                font-weight: 600;
                color: #4a5568;
                margin: 1.2em 0 0.4em;
              }
              
              /* Bloques especiales */
              .blog-quote {
                border-left: 4px solid #4a5568;
                padding: 1em 2em;
                margin: 1.5em 0;
                background: #f7fafc;
                font-style: italic;
              }
              
              .blog-note {
                background: #ebf8ff;
                border: 1px solid #90cdf4;
                border-radius: 8px;
                padding: 1em;
                margin: 1em 0;
              }
              
              .blog-alert {
                background: #fff5f5;
                border: 1px solid #feb2b2;
                border-radius: 8px;
                padding: 1em;
                margin: 1em 0;
                color: #c53030;
              }
              
              /* Elementos inline */
              .highlight {
                background: #fef3c7;
                padding: 0.2em 0.4em;
                border-radius: 4px;
              }
              
              .underline-text {
                border-bottom: 2px solid #4a5568;
              }
              
              /* Meta información */
              .blog-meta {
                color: #718096;
                font-size: 0.9em;
                margin-bottom: 2em;
              }
              
              /* Imágenes */
              .featured-image {
                width: 100%;
                height: auto;
                border-radius: 8px;
                margin: 1em 0;
              }
              
              /* Review específicos */
              .game-meta {
                background: #f7fafc;
                padding: 1em;
                border-radius: 8px;
                margin: 1em 0;
              }
              
              /* Tutorial específicos */
              .tutorial-meta {
                background: #f0fff4;
                padding: 1em;
                border-radius: 8px;
                margin: 1em 0;
              }

              /* Código */
              .code-block { 
                margin: 1em 0; 
                background: #282c34;
                border-radius: 8px;
                overflow: hidden;
              }
              
              .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                background: #21252b;
                border-bottom: 1px solid #373b41;
              }
              
              .code-language {
                color: #abb2bf;
                font-weight: 600;
                text-transform: uppercase;
              }
              
              .copy-button {
                padding: 6px 12px;
                background: #323842;
                color: #abb2bf;
                border: 1px solid #373b41;
                border-radius: 4px;
                cursor: pointer;
              }
              
              pre[class*="language-"] { 
                margin: 0; 
                padding: 16px; 
                background: #282c34;
                font-size: 0.9em;
              }
              
              code[class*="language-"] { 
                color: #abb2bf; 
                font-family: 'Fira Code', monospace;
              }

              /* Contenedores multimedia */
              .video-container {
                position: relative;
                padding-bottom: 56.25%;
                height: 0;
                overflow: hidden;
                max-width: 100%;
                margin: 1em 0;
              }
              
              .video-container iframe {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
              }

              .audio-container {
                margin: 1em 0;
                padding: 1em;
                background: #f7fafc;
                border-radius: 8px;
              }
              
              .audio-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.5em;
              }
              
              .audio-title {
                font-weight: bold;
                color: #2d3748;
              }
              
              .delete-audio-btn {
                background: none;
                border: none;
                color: #e53e3e;
                cursor: pointer;
                padding: 4px;
                border-radius: 4px;
                display: flex;
                align-items: center;
                transition: background-color 0.2s;
              }
              
              .delete-audio-btn:hover {
                background-color: #fed7d7;
              }
              
              audio {
                width: 100%;
                margin-top: 0.5em;
              }
            `,

            setup: (editor) => {
              editor.ui.registry.addButton('youtube', {
                text: 'YouTube',
                onAction: handleYouTubeEmbed
              });

              editor.ui.registry.addButton('customlink', {
                text: 'Insertar Enlace',
                onAction: handleLinkInsert
              });

              editor.ui.registry.addButton('insertcode', {
                text: 'Insertar Código',
                onAction: () => setIsCodeModalOpen(true),
                icon: 'code'
              });

              editor.ui.registry.addButton('audio', {
                text: 'Audio',
                onAction: handleAudioUpload
              });
            }
          }}
        />

        <div className="mt-6 flex justify-end">
          <button
            type="submit"
            disabled={isSubmitting}
            className={`
              px-6 py-2 bg-blue-600 text-white rounded-md
              hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
              transition-colors duration-200
              disabled:opacity-50 disabled:cursor-not-allowed
            `}
          >
            {isSubmitting ? 'Actualizando...' : 'Actualizar Post'}
          </button>
        </div>
      </form>

      <CodeInputModal
        isOpen={isCodeModalOpen}
        onClose={() => setIsCodeModalOpen(false)}
        onSubmit={handleCodeSubmit}
      />
    </div>
  );
}

export default EditPost;
</file>

<file path="src/components/Login.js">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { signInWithEmailAndPassword, signOut } from "firebase/auth";
import { auth } from '../config/firebase-config';

function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const navigate = useNavigate();

  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('auth-token');
    setIsLoggedIn(!!token);
  }, []);

  const handleSubmit = async (event) => {
    event.preventDefault();
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const token = await userCredential.user.getIdToken();

      localStorage.setItem('auth-token', token);
      localStorage.setItem('user', email);
      localStorage.setItem('userRole', "admin");

      console.log('Login successful:', email);
      console.log('userRole:', "admin");

      setIsLoggedIn(true);
      navigate('/edit');

    } catch (error) {
      console.error('Error during login:', error);
      // Display error message to user
    }
  };

  const handleLogout = async () => {
    try {
      await signOut(auth);
      localStorage.removeItem('auth-token');
      localStorage.removeItem('user');
      localStorage.removeItem('userRole');
      setIsLoggedIn(false);
      navigate('/');
      console.log('Logout successful');
    } catch (error) {
      console.error('Error during logout:', error);
    }
  };

  if (isLoggedIn) {
    return (
      <div>
        <p>You are logged in.</p>
        <button onClick={handleLogout}>Deslogearse</button>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Email:
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </label>
      <label>
        Password:
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
      </label>
      <button type="submit">Login</button>
    </form>
  );
}

export default LoginForm;
</file>

<file path="src/components/TextEditor.js">
import React, { useState, useEffect, useRef } from 'react';
import { Editor } from '@tinymce/tinymce-react';
import { useNavigate } from 'react-router-dom';
import gameRegistry from './GameRegistry';
import Prism from 'prismjs';
import 'prismjs/themes/prism-okaidia.css';

import 'prismjs/plugins/toolbar/prism-toolbar';
import 'prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard';

// Importar lenguajes adicionales de Prism
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-tsx';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';

// Componente Modal para ingresar código
const CodeInputModal = ({ isOpen, onClose, onSubmit }) => {
  const [code, setCode] = useState('');
  const [language, setLanguage] = useState('javascript');

  const languages = [
    'javascript', 'python', 'java', 'html', 'css',
    'typescript', 'jsx', 'tsx', 'sql', 'json', 'bash'
  ];

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(code, language);
    setCode('');
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <h3>Insertar Código</h3>
        <select
          value={language}
          onChange={(e) => setLanguage(e.target.value)}
          className="language-select"
        >
          {languages.map(lang => (
            <option key={lang} value={lang}>{lang}</option>
          ))}
        </select>
        <textarea
          value={code}
          onChange={(e) => setCode(e.target.value)}
          placeholder="Pega tu código aquí..."
          className="code-input"
          autoFocus
        />
        <div className="modal-buttons">
          <button onClick={handleSubmit} className="submit-btn">Insertar</button>
          <button onClick={onClose} className="cancel-btn">Cancelar</button>
        </div>
      </div>
    </div>
  );
};

// Custom hooks
const useImageUpload = () => {
  const [image, setImage] = useState(null);
  const [imagePreview, setImagePreview] = useState('');

  const handleImageChange = (event) => {
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0];
      setImage(file);
      setImagePreview(URL.createObjectURL(file));
    }
  };

  return [image, imagePreview, handleImageChange];
};

const useFormValidation = (title, content, image) => {
  const [errors, setErrors] = useState({});

  const validate = () => {
    const newErrors = {};
    if (!title.trim()) newErrors.title = 'El título es requerido';
    if (!content.trim()) newErrors.content = 'El contenido es requerido';
    if (!image) newErrors.image = 'La imagen es requerida';
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  return [errors, validate];
};

// Componente Alert
const Alert = ({ message, type, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose();
    }, 5000);
    return () => clearTimeout(timer);
  }, [onClose]);

  return (
    <div className={`alert alert-${type}`}>
      {message}
      <button className="alert-close" onClick={onClose}>×</button>
    </div>
  );
};

function TextEditor() {
  const [content, setContent] = useState('');
  const [title, setTitle] = useState('');
  const [author, setAuthor] = useState('');
  const [juegoSeleccionado, setJuegoSeleccionado] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [alert, setAlert] = useState(null);
  const [isCodeModalOpen, setIsCodeModalOpen] = useState(false);

  const editorRef = useRef(null);
  const navigate = useNavigate();

  const [image, imagePreview, handleImageChange] = useImageUpload();
  const [errors, validate] = useFormValidation(title, content, image);

  useEffect(() => {
    const storedAuthor = localStorage.getItem('user');
    if (storedAuthor) setAuthor(storedAuthor);
  }, []);

  const handleEditorChange = (content) => setContent(content);

  const handleLinkInsert = () => {
    const linkUrl = prompt("Por favor, ingresa la URL del enlace:");
    const linkText = prompt("Por favor, ingresa el texto para mostrar:");
    if (linkUrl && linkText) {
      const linkHtml = `<a href="${linkUrl}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
      editorRef.current?.insertContent(linkHtml);
    }
  };

  const handleYouTubeEmbed = () => {
    const youtubeUrl = prompt("Por favor, ingresa la URL del video de YouTube:");
    if (youtubeUrl) {
      const videoId = extractYouTubeId(youtubeUrl);
      if (videoId) {
        const embedCode = `<div class="video-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`;
        editorRef.current?.insertContent(embedCode);
      } else {
        setAlert({
          type: 'error',
          message: 'URL de YouTube no válida'
        });
      }
    }
  };

  const handleCodeSubmit = (code, language) => {
    if (code) {
      const codeBlockId = `code-block-${Date.now()}`;
      const preElement = document.createElement('pre');
      const codeElement = document.createElement('code');

      preElement.id = codeBlockId;
      preElement.className = `language-${language}`;
      codeElement.className = `language-${language}`;
      codeElement.textContent = code;
      preElement.appendChild(codeElement);

      Prism.plugins.toolbar.registerButton('copy-to-clipboard', {
        text: 'Copy',
        onClick: function () {
          navigator.clipboard.writeText(code).then(() => {
            const copyButton = document.querySelector(`#${codeBlockId} .copy-to-clipboard`);
            copyButton.textContent = 'Copied!';
            setTimeout(() => copyButton.textContent = 'Copy', 2000);
          });
        }
      });

      editorRef.current?.insertContent(preElement.outerHTML);
      Prism.highlightElement(preElement);
    }
  };

  const handleAudioUpload = async () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.mp3,.wav,.ogg,.aac,.m4a,.webm';
    input.multiple = true;
    const apiUrl = process.env.REACT_APP_API_URL;

    input.onchange = async (e) => {
      const files = Array.from(e.target.files);

      for (const file of files) {
        const formData = new FormData();
        formData.append('audio', file);

        try {
          setAlert({
            type: 'info',
            message: `Subiendo ${file.name}...`
          });

          const response = await fetch(`${apiUrl}/api/upload-audio`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('auth-token')}`
            },
            body: formData
          });

          if (!response.ok) {
            throw new Error(`Error al subir el archivo`);
          }

          const data = await response.json();

          const audioHtml = `
            <div class="audio-container">
              <div class="audio-title">${file.name}</div>
              <audio controls>
                <source src="${data.audioUrl}" type="${file.type}">
                Your browser does not support the audio element.
              </audio>
            </div>
          `;
          editorRef.current?.insertContent(audioHtml);

          setAlert({
            type: 'success',
            message: `${file.name} subido exitosamente!`
          });

        } catch (error) {
          setAlert({
            type: 'error',
            message: `Error al subir ${file.name}: ${error.message}`
          });
        }
      }
    };
    input.click();
  };

  const extractYouTubeId = (url) => {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
  };

  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!validate()) {
      setAlert({
        type: 'error',
        message: 'Por favor, corrige los errores antes de enviar'
      });
      return;
    }

    setIsSubmitting(true);
    setAlert(null);

    const formData = new FormData();
    formData.append('title', title);
    formData.append('content', editorRef.current.getContent());
    if (image) formData.append('image', image);
    formData.append('author', author);
    if (juegoSeleccionado) formData.append('juego', juegoSeleccionado);

    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/posts`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth-token')}`,
        },
        body: formData
      });

      if (!response.ok) {
        throw new Error('Error al crear el post');
      }

      setAlert({
        type: 'success',
        message: '¡Post creado exitosamente!'
      });

      setTimeout(() => navigate('/blog'), 1500);
    } catch (error) {
      setAlert({
        type: 'error',
        message: error.message
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="editor-container">
      {alert && (
        <Alert
          message={alert.message}
          type={alert.type}
          onClose={() => setAlert(null)}
        />
      )}

      <form onSubmit={handleSubmit} className="editor-form">
        <div className="form-group">
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="Título del Post"
            className={`form-control ${errors.title ? 'error' : ''}`}
          />
          {errors.title && <p className="error-message">{errors.title}</p>}
        </div>

        <div className="form-group">
          <div className="image-upload-container">
            <input
              type="file"
              onChange={handleImageChange}
              accept="image/*"
              className={errors.image ? 'error' : ''}
            />
            {imagePreview && (
              <img src={imagePreview} alt="Preview" className="image-preview" />
            )}
          </div>
          {errors.image && <p className="error-message">{errors.image}</p>}
        </div>

        <select
          value={juegoSeleccionado}
          onChange={(e) => {
            setJuegoSeleccionado(e.target.value);
            if (e.target.value) {
              editorRef.current?.insertContent(`{{{Juego:${e.target.value}}}} `);
            }
          }}
          className="form-control"
        >
          <option value="">Selecciona un juego (opcional)</option>
          {Object.entries(gameRegistry).map(([key, { name }]) => (
            <option key={key} value={key}>{name}</option>
          ))}
        </select>

        <Editor
          apiKey='d2cmewtag6kjp2p8p17tsmvvvqjqxaqifks441d9txizwi3g'
          onInit={(evt, editor) => editorRef.current = editor}
          initialValue="<p>Contenido del Post</p>"
          onEditorChange={handleEditorChange}
          init={{
            height: 500,
            menubar: false,
            plugins: [
              'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
              'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
              'insertdatetime', 'media', 'table', 'help', 'wordcount', 'emoticons',
              'visualchars', 'quickbars', 'pagebreak', 'nonbreaking', 'template'
            ],
            toolbar1: 'styles | fontfamily fontsize | forecolor backcolor | template',
            toolbar2: 'bold italic underline strikethrough | alignleft aligncenter alignright alignjustify | bullist numlist | outdent indent',
            toolbar3: 'removeformat | table image media | link customlink youtube | emoticons insertcode audio pagebreak | code fullscreen help',
            style_formats: [
              {
                title: 'Encabezados', items: [
                  { title: 'Título principal', block: 'h1', classes: 'blog-title' },
                  { title: 'Subtítulo', block: 'h2', classes: 'blog-subtitle' },
                  { title: 'Sección', block: 'h3', classes: 'blog-section' }
                ]
              },
              {
                title: 'Bloques', items: [
                  { title: 'Cita destacada', block: 'blockquote', classes: 'blog-quote' },
                  { title: 'Nota al margen', block: 'div', classes: 'blog-note' },
                  { title: 'Caja de alerta', block: 'div', classes: 'blog-alert' }
                ]
              },
              {
                title: 'Inline', items: [
                  { title: 'Texto destacado', inline: 'span', classes: 'highlight' },
                  { title: 'Código inline', inline: 'code' },
                  { title: 'Texto subrayado', inline: 'span', classes: 'underline-text' }
                ]
              }
            ],

            templates: [
              {
                id: 'blog-article',
                title: 'Artículo de Blog',
                description: 'Estructura básica para un artículo',
                content: `
                  <h1 class="blog-title">Título del Artículo</h1>
                  <p class="blog-meta">Por [Autor] | [Fecha]</p>
                  <img src="placeholder.jpg" alt="Imagen destacada" class="featured-image"/>
                  <h2 class="blog-subtitle">Introducción</h2>
                  <p>Tu introducción aquí...</p>
                  <h2 class="blog-subtitle">Desarrollo</h2>
                  <p>Contenido principal...</p>
                  <h2 class="blog-subtitle">Conclusión</h2>
                  <p>Tus conclusiones aquí...</p>
                `
              },
              {
                id: 'game-review',
                title: 'Review de Juego',
                description: 'Plantilla para reviews de juegos',
                content: `
                  <h1 class="blog-title">Review: [Nombre del Juego]</h1>
                  <div class="game-meta">
                    <p><strong>Género:</strong> [Género]</p>
                    <p><strong>Plataforma:</strong> [Plataforma]</p>
                    <p><strong>Puntuación:</strong> ⭐⭐⭐⭐☆</p>
                  </div>
                  <h2>Resumen</h2>
                  <p>Resumen breve del juego...</p>
                  <h2>Gráficos y Sonido</h2>
                  <p>Análisis de los aspectos técnicos...</p>
                  <h2>Jugabilidad</h2>
                  <p>Descripción de la mecánica del juego...</p>
                  <h2>Conclusión</h2>
                  <p>Veredicto final...</p>
                `
              },
              {
                id: 'technical-tutorial',
                title: 'Tutorial Técnico',
                description: 'Estructura para tutoriales',
                content: `
                  <h1 class="blog-title">Tutorial: [Título]</h1>
                  <div class="tutorial-meta">
                    <p><strong>Nivel:</strong> [Principiante/Intermedio/Avanzado]</p>
                    <p><strong>Tiempo estimado:</strong> [X minutos]</p>
                  </div>
                  <h2>Requisitos Previos</h2>
                  <ul>
                    <li>Requisito 1</li>
                    <li>Requisito 2</li>
                  </ul>
                  <h2>Paso 1: [Título del Paso]</h2>
                  <p>Instrucciones detalladas...</p>
                  <h2>Paso 2: [Título del Paso]</h2>
                  <p>Instrucciones detalladas...</p>
                  <h2>Conclusión</h2>
                  <p>Resumen y siguientes pasos...</p>
                `
              }
            ],

            content_style: `
              body { 
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                font-size: 16px;
                line-height: 1.6;
                color: #2d3748;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
              }
              
              /* Estilos para títulos */
              .blog-title {
                font-size: 2.5em;
                font-weight: 800;
                color: #1a202c;
                margin-bottom: 0.5em;
                line-height: 1.2;
              }
              
              .blog-subtitle {
                font-size: 1.8em;
                font-weight: 700;
                color: #2d3748;
                margin: 1.5em 0 0.5em;
              }
              
              .blog-section {
                font-size: 1.4em;
                font-weight: 600;
                color: #4a5568;
                margin: 1.2em 0 0.4em;
              }
              
              /* Bloques especiales */
              .blog-quote {
                border-left: 4px solid #4a5568;
                padding: 1em 2em;
                margin: 1.5em 0;
                background: #f7fafc;
                font-style: italic;
              }
              
              .blog-note {
                background: #ebf8ff;
                border: 1px solid #90cdf4;
                border-radius: 8px;
                padding: 1em;
                margin: 1em 0;
              }
              
              .blog-alert {
                background: #fff5f5;
                border: 1px solid #feb2b2;
                border-radius: 8px;
                padding: 1em;
                margin: 1em 0;
                color: #c53030;
              }
              
              /* Elementos inline */
              .highlight {
                background: #fef3c7;
                padding: 0.2em 0.4em;
                border-radius: 4px;
              }
              
              .underline-text {
                border-bottom: 2px solid #4a5568;
              }
              
              /* Meta información */
              .blog-meta {
                color: #718096;
                font-size: 0.9em;
                margin-bottom: 2em;
              }
              
              /* Imágenes */
              .featured-image {
                width: 100%;
                height: auto;
                border-radius: 8px;
                margin: 1em 0;
              }
              
              /* Review específicos */
              .game-meta {
                background: #f7fafc;
                padding: 1em;
                border-radius: 8px;
                margin: 1em 0;
              }
              
              /* Tutorial específicos */
              .tutorial-meta {
                background: #f0fff4;
                padding: 1em;
                border-radius: 8px;
                margin: 1em 0;
              }

              /* Código */
              .code-block { 
                margin: 1em 0; 
                background: #282c34;
                border-radius: 8px;
                overflow: hidden;
              }
              .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                background: #21252b;
                border-bottom: 1px solid #373b41;
              }
              .code-language {
                color: #abb2bf;
                font-weight: 600;
                text-transform: uppercase;
              }
              .copy-button {
                padding: 6px 12px;
                background: #323842;
                color: #abb2bf;
                border: 1px solid #373b41;
                border-radius: 4px;
                cursor: pointer;
              }
              pre[class*="language-"] { 
                margin: 0; 
                padding: 16px; 
                background: #282c34;
                font-size: 0.9em;
              }
              code[class*="language-"] { 
                color: #abb2bf; 
                font-family: 'Fira Code', monospace;
              }

              /* Video Container */
              .video-container {
                position: relative;
                padding-bottom: 56.25%;
                height: 0;
                overflow: hidden;
                margin: 1em 0;
              }
              .video-container iframe {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
              }

              /* Audio Container */
              .audio-container {
                background: #f7fafc;
                border-radius: 8px;
                padding: 1em;
                margin: 1em 0;
              }
              .audio-title {
                font-weight: 600;
                margin-bottom: 0.5em;
                color: #4a5568;
              }
              audio {
                width: 100%;
              }
            `,
            setup: (editor) => {
              editor.ui.registry.addButton('youtube', {
                text: 'YouTube',
                onAction: handleYouTubeEmbed
              });
              editor.ui.registry.addButton('customlink', {
                text: 'Insertar Enlace',
                onAction: handleLinkInsert
              });
              editor.ui.registry.addButton('insertcode', {
                text: 'Insertar Código',
                onAction: () => setIsCodeModalOpen(true),
                icon: 'code'
              });
              editor.ui.registry.addButton('audio', {
                text: 'Audio',
                onAction: () => handleAudioUpload()
              });
            }
          }}
        />
        {errors.content && <p className="error-message">{errors.content}</p>}

        <button
          type="submit"
          disabled={isSubmitting}
          className={`submit-button ${isSubmitting ? 'submitting' : ''}`}
        >
          {isSubmitting ? 'Guardando...' : 'Guardar Post'}
        </button>
      </form>

      <CodeInputModal
        isOpen={isCodeModalOpen}
        onClose={() => setIsCodeModalOpen(false)}
        onSubmit={handleCodeSubmit}
      />
    </div>
  );
}

export default TextEditor;
</file>

<file path="src/css/contact.css">
/* src/css/contact.css - Versión optimizada para escritorio y móvil */

.contact-page-container {
  /* Aumentamos el ancho máximo para que se vea mejor en escritorio */
  max-width: 1100px;
  margin: 40px auto;
  padding: 30px;
  background-color: #0a192f;
  /* Fondo oscuro para toda la página */
  border-radius: 10px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
  color: #e6f1ff;
  animation: fadeIn 0.6s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(15px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Estilo del título principal */
.contact-title.section-title {
  font-size: 2.5rem;
  margin-bottom: 2rem;
  text-align: center;
  color: #ffffff;
  position: relative;
  padding-bottom: 1rem;
  font-weight: 700;
  letter-spacing: 1px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.contact-title.section-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 4px;
  background: linear-gradient(to right, #64ffda, #00bfa5);
  border-radius: 2px;
  box-shadow: 0 0 10px rgba(100, 255, 218, 0.6);
}

.contact-intro {
  text-align: center;
  color: #ffffff;
  /* Texto blanco para mayor contraste */
  margin-bottom: 40px;
  line-height: 1.7;
  max-width: 650px;
  margin-left: auto;
  margin-right: auto;
  font-size: 1.1rem;
  font-weight: 400;
}

.contact-content-wrapper {
  display: flex;
  /* Por defecto (móvil), los elementos estarán en columna */
  flex-direction: column;
  gap: 40px;
  background-color: #112240;
  /* Fondo ligeramente más claro para el contenido */
  border-radius: 8px;
  padding: 30px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Media Query para pantallas de escritorio (a partir de 768px de ancho) */
@media (min-width: 768px) {
  .contact-content-wrapper {
    /* Cambiamos la dirección a fila para poner los elementos lado a lado */
    flex-direction: row;
  }

  .contact-form-container {
    /* El formulario ocupará 2/3 del espacio */
    flex: 2;
    margin-right: 30px;
  }

  .contact-alternatives {
    /* Los enlaces sociales ocuparán 1/3 del espacio */
    flex: 1;
    /* Eliminamos el borde superior y añadimos uno izquierdo como separador vertical */
    border-top: none;
    padding-top: 0;
    border-left: 1px solid rgba(100, 255, 218, 0.3);
    padding-left: 30px;
  }
}

.contact-form-container {
  width: 100%;
  /* Ocupa todo el ancho disponible en su contenedor flex */
}

.contact-form .form-group {
  margin-bottom: 25px;
}

.contact-form label {
  display: block;
  margin-bottom: 10px;
  color: #64ffda;
  /* Color de acento para los labels */
  font-size: 1.1rem;
  font-weight: 600;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  letter-spacing: 0.5px;
}

.contact-form input,
.contact-form textarea {
  width: 100%;
  padding: 14px;
  border: 2px solid #233554;
  /* Borde más oscuro */
  border-radius: 6px;
  background-color: #0a192f;
  /* Fondo oscuro */
  color: #ffffff;
  /* Texto blanco para máximo contraste */
  font-size: 1rem;
  transition: all 0.3s ease;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.contact-form input::placeholder,
.contact-form textarea::placeholder {
  color: #8892b0;
  /* Color más visible para placeholders */
}

.contact-form input:focus,
.contact-form textarea:focus {
  outline: none;
  border-color: #64ffda;
  background-color: #172a45;
  /* Fondo ligeramente más claro al enfocar */
  box-shadow: 0 0 0 2px rgba(100, 255, 218, 0.2);
}

.contact-form textarea {
  min-height: 180px;
  resize: vertical;
}

.submit-button {
  background-color: transparent;
  border: 2px solid #64ffda;
  color: #64ffda;
  padding: 12px 30px;
  font-size: 1.1rem;
  font-weight: 600;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 10px;
  letter-spacing: 0.5px;
  text-transform: uppercase;
}

.submit-button:hover:not(:disabled) {
  background-color: rgba(100, 255, 218, 0.1);
  box-shadow: 0 0 15px rgba(100, 255, 218, 0.3);
  transform: translateY(-2px);
}

.submit-button:active:not(:disabled) {
  transform: translateY(1px);
}

.submit-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.status-message {
  margin-top: 25px;
  padding: 15px;
  border-radius: 6px;
  font-weight: 600;
  text-align: center;
}

.status-message.success {
  background-color: rgba(100, 255, 218, 0.1);
  color: #64ffda;
  border: 1px solid #64ffda;
}

.status-message.error {
  background-color: rgba(255, 100, 100, 0.1);
  color: #ff6464;
  border: 1px solid #ff6464;
}

/* Contact Alternatives */
.contact-alternatives {
  text-align: center;
  border-top: 1px solid rgba(100, 255, 218, 0.3);
  padding-top: 30px;
}

.contact-alternatives h3 {
  margin-bottom: 25px;
  color: #ffffff;
  font-size: 1.5rem;
  position: relative;
  padding-bottom: 10px;
}

.contact-alternatives h3::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 50px;
  height: 3px;
  background: #64ffda;
  border-radius: 2px;
}

.social-links-contact {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  margin-top: 30px;
}

.social-links-contact a {
  color: #ccd6f6;
  /* Color más claro para mejor visibilidad */
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 1.1rem;
  padding: 10px 15px;
  border-radius: 6px;
  transition: all 0.3s ease;
  width: 100%;
  max-width: 220px;
  justify-content: center;
  border: 1px solid transparent;
}

.social-links-contact a:hover {
  color: #64ffda;
  background-color: rgba(100, 255, 218, 0.05);
  border: 1px solid rgba(100, 255, 218, 0.3);
  transform: translateY(-2px);
}

.social-links-contact svg {
  font-size: 1.5rem;
}

/* Media queries para dispositivos móviles */
@media (max-width: 768px) {
  .contact-page-container {
    padding: 20px;
    margin: 20px auto;
  }

  .contact-title.section-title {
    font-size: 2rem;
  }

  .contact-content-wrapper {
    padding: 20px;
  }

  .contact-form input,
  .contact-form textarea {
    padding: 12px;
  }

  .contact-alternatives {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid rgba(100, 255, 218, 0.3);
    border-left: none;
  }
}

/* Añadir un pequeño efecto de brillo al formulario */
.contact-form-container {
  position: relative;
  overflow: hidden;
}

.contact-form-container::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(100, 255, 218, 0.1) 0%, transparent 70%);
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  z-index: -1;
}

.contact-form-container:hover::before {
  opacity: 1;
}
</file>

<file path="src/css/GamePage.css">
.games-page {
   padding: 20px;
   max-width: 1200px;
   margin: 0 auto;
}

.games-section {
   margin-bottom: 40px;
}

.games-section h2 {
   color: #1f2937;
   margin-bottom: 20px;
   font-size: 1.8rem;
}

.games-grid {
   display: grid;
   grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
   gap: 24px;
   margin-top: 20px;
}

.game-card {
   background: #ffffff;
   border-radius: 12px;
   overflow: hidden;
   box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
   transition: transform 0.2s, box-shadow 0.2s;
   cursor: pointer;
   text-decoration: none;
   color: inherit;
   display: flex;
   flex-direction: column;
}

.game-card:hover {
   transform: translateY(-4px);
   box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
}

.game-card-image-container {
   width: 100%;
   height: 180px;
   overflow: hidden;
}

.game-card-image {
   width: 100%;
   height: 100%;
   object-fit: cover;
   transition: transform 0.3s ease;
}

.game-card:hover .game-card-image {
   transform: scale(1.05);
}

.game-card-content {
   padding: 16px;
}

.game-card-content h3 {
   color: #1f2937;
   font-size: 1.25rem;
   margin-bottom: 8px;
}

.game-card-content p {
   color: #6b7280;
   font-size: 0.95rem;
   line-height: 1.5;
}

/* Estilos para las salas */
.room-card {
   background: #fff;
   border-radius: 12px;
   padding: 24px;
   box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
   transition: box-shadow 0.3s ease;
}

.room-card:hover {
   box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
}

.room-card h3 {
   color: #1f2937;
   font-size: 1.4rem;
   margin-bottom: 8px;
}

.room-card p {
   color: #6b7280;
   margin-bottom: 16px;
}

.room-status {
   margin: 20px 0;
   padding: 16px;
   background: #f9fafb;
   border-radius: 8px;
}

.game-status {
   margin-bottom: 16px;
}

.status-indicator {
   padding: 6px 12px;
   border-radius: 6px;
   font-size: 0.9em;
   font-weight: 500;
   display: inline-block;
}

.status-indicator.in-progress {
   background-color: #fef3c7;
   color: #92400e;
}

.status-indicator.waiting {
   background-color: #e0e7ff;
   color: #3730a3;
}

.players-info {
   margin-top: 16px;
}

.player-count {
   display: block;
   margin-bottom: 12px;
   color: #6b7280;
   font-size: 0.95rem;
}

.players-list {
   display: flex;
   gap: 24px;
   margin-top: 12px;
}

.team {
   flex: 1;
   background: #ffffff;
   padding: 12px;
   border-radius: 8px;
   box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.team h4 {
   margin: 0 0 12px 0;
   font-size: 1rem;
   color: #374151;
   text-align: center;
}

.player-name {
   display: block;
   padding: 6px 10px;
   margin: 6px 0;
   border-radius: 6px;
   font-size: 0.9em;
   text-align: center;
   transition: transform 0.2s ease;
}

.player-name:hover {
   transform: translateX(4px);
}

.player-name.mammals {
   background-color: #dbeafe;
   color: #1e40af;
}

.player-name.reptiles {
   background-color: #fee2e2;
   color: #991b1b;
}

.join-button {
   width: 100%;
   padding: 12px;
   background-color: #3b82f6;
   color: white;
   border: none;
   border-radius: 8px;
   cursor: pointer;
   font-size: 1rem;
   font-weight: 500;
   transition: all 0.2s ease;
   margin-top: 16px;
}

.join-button:hover {
   background-color: #2563eb;
   transform: translateY(-2px);
}

.join-button:active {
   transform: translateY(0);
}

.back-button {
   padding: 8px 16px;
   background-color: #e5e7eb;
   color: #374151;
   border: none;
   border-radius: 6px;
   cursor: pointer;
   font-size: 0.95rem;
   margin-bottom: 24px;
   transition: all 0.2s ease;
}

.back-button:hover {
   background-color: #d1d5db;
}

/* Responsive adjustments */
@media (max-width: 768px) {
   .games-grid {
       grid-template-columns: 1fr;
   }

   .players-list {
       flex-direction: column;
       gap: 16px;
   }

   .room-card {
       padding: 16px;
   }
}

/* Estilos mejorados para la sección de salas */
.rooms-grid {
   display: grid;
   grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
   gap: 30px;
   margin-top: 30px;
}

.room-card {
   background: #ffffff;
   border-radius: 16px;
   padding: 24px;
   box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
   transition: all 0.3s ease;
   position: relative;
   overflow: hidden;
   border: 1px solid #e5e7eb;
}

.room-card::before {
   content: '';
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   height: 4px;
   background: linear-gradient(90deg, #3b82f6, #ef4444);
}

.room-card h3 {
   color: #1f2937;
   font-size: 1.5rem;
   margin-bottom: 12px;
   font-weight: 600;
}

.room-card p {
   color: #6b7280;
   margin-bottom: 20px;
   font-size: 0.95rem;
   line-height: 1.5;
}

.room-status {
   background: #f8fafc;
   margin: 20px -24px;
   padding: 20px 24px;
   border-top: 1px solid #e5e7eb;
   border-bottom: 1px solid #e5e7eb;
}

.game-status {
   margin-bottom: 20px;
   text-align: center;
}

.status-indicator {
   padding: 8px 16px;
   border-radius: 30px;
   font-size: 0.9em;
   font-weight: 500;
   display: inline-block;
}

.status-indicator.in-progress {
   background: linear-gradient(45deg, #fef3c7, #fde68a);
   color: #92400e;
   box-shadow: 0 2px 8px rgba(146, 64, 14, 0.1);
}

.status-indicator.waiting {
   background: linear-gradient(45deg, #e0e7ff, #c7d2fe);
   color: #3730a3;
   box-shadow: 0 2px 8px rgba(55, 48, 163, 0.1);
}

.players-info {
   margin-top: 20px;
}

.player-count {
   text-align: center;
   display: block;
   margin-bottom: 16px;
   color: #4b5563;
   font-size: 1rem;
   font-weight: 500;
}

.players-list {
   display: grid;
   grid-template-columns: 1fr 1fr;
   gap: 20px;
   margin-top: 16px;
}

.team {
   background: #ffffff;
   padding: 16px;
   border-radius: 12px;
   box-shadow: 0 2px 12px rgba(0, 0, 0, 0.05);
}

.team h4 {
   margin: 0 0 12px 0;
   font-size: 1.1rem;
   color: #374151;
   text-align: center;
   font-weight: 600;
   padding-bottom: 8px;
   border-bottom: 2px solid #e5e7eb;
}

.player-name {
   display: flex;
   align-items: center;
   padding: 8px 12px;
   margin: 8px 0;
   border-radius: 8px;
   font-size: 0.95em;
   transition: all 0.2s ease;
}

.player-name::before {
   content: '•';
   margin-right: 8px;
   font-size: 1.2em;
}

.player-name.mammals {
   background: linear-gradient(45deg, #dbeafe, #bfdbfe);
   color: #1e40af;
}

.player-name.reptiles {
   background: linear-gradient(45deg, #fee2e2, #fecaca);
   color: #991b1b;
}

.join-button {
   width: 100%;
   padding: 14px;
   margin-top: 24px;
   background: linear-gradient(45deg, #3b82f6, #2563eb);
   color: white;
   border: none;
   border-radius: 12px;
   cursor: pointer;
   font-size: 1.1rem;
   font-weight: 600;
   transition: all 0.3s ease;
   text-transform: uppercase;
   letter-spacing: 0.5px;
   box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
}

.join-button:hover {
   transform: translateY(-2px);
   box-shadow: 0 6px 16px rgba(37, 99, 235, 0.3);
}

.join-button:active {
   transform: translateY(0);
   box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
}

/* Responsive adjustments */
@media (max-width: 768px) {
   .rooms-grid {
       grid-template-columns: 1fr;
       padding: 0 16px;
   }

   .room-card {
       padding: 20px;
   }

   .players-list {
       grid-template-columns: 1fr;
   }

   .status-indicator {
       font-size: 0.85em;
   }
}
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="Web site created using create-react-app" />

  <link rel="icon" href="%PUBLIC_URL%/logo_backup.png" type="image/png" />
  <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
  <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
  <title>Dante Collazzi</title>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-KBERYP2TEW"></script>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-D7MQZQBNYT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-D7MQZQBNYT');
  </script>

  <!-- MediaPipe Hand Tracking Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
  <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
</body>

</html>
</file>

<file path="src/components/Header.js">
import React, { useState, useEffect } from 'react';
import { Link, useLocation } from 'react-router-dom';
import '../css/header.css';
import logoImage from '../images/logo.png'; // Asegúrate de que la ruta sea correcta

const Header = () => {
  const [username, setUsername] = useState('');
  const [scrollPosition, setScrollPosition] = useState(0);
  const location = useLocation();

  useEffect(() => {
    const storedUsername = localStorage.getItem('user');
    if (storedUsername) setUsername(storedUsername);

    const handleScroll = () => {
      setScrollPosition(window.scrollY);
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const containerStyle = {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    width: '100%',
    // Eliminamos maxWidth y margin
  };

  const headerStyle = {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    height: '80px',
    backgroundColor: `rgba(243, 243, 243, ${Math.max(0.8, Math.min(scrollPosition / 300, 0.95))})`,
    transition: 'all 0.3s ease',
    zIndex: 1000,
    boxShadow: scrollPosition > 50 ? '0 2px 10px rgba(0, 0, 0, 0.1)' : 'none',
    display: 'flex',
    alignItems: 'center',
    padding: '0', // Eliminamos el padding
  };

  return (
    <header style={headerStyle}>
      <div style={containerStyle}>
        <Link to="/" className="logo-link">
          <div className="logo-container">
            <img src={logoImage} alt="Logo" className="circular-logo" />
          </div>
        </Link>
        <div className="nav-welcome-container">
          <nav>
            <Link to="/" className={`nav-link ${location.pathname === '/' ? 'active' : ''}`}>Home</Link>
            <Link to="/blog" className={`nav-link ${location.pathname === '/blog' ? 'active' : ''}`}>Blog</Link>
            <Link to="/games" className={`nav-link ${location.pathname === '/games' ? 'active' : ''}`}>Games</Link>
            <Link to="/about" className={`nav-link ${location.pathname === '/about' ? 'active' : ''}`}>About</Link>
            <Link to="/contact" className={`nav-link ${location.pathname === '/contact' ? 'active' : ''}`}>Contact</Link>
          </nav>
          {username && <span className="welcome-message">Bienvenido, {username}</span>}
        </div>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="src/css/about.css">
/* src/css/about.css - Versión optimizada para escritorio y móvil */

.about-container {
  /* Aumentamos el ancho máximo para el diseño de dos columnas */
  max-width: 1200px;
  margin: 40px auto;
  padding: 30px;
  background-color: #0a192f;
  /* Fondo oscuro para combinar con la página de contacto */
  border-radius: 10px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
  color: #e6f1ff;
  /* Texto claro para contraste */
  animation: fadeIn 0.6s ease-out;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.7;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(15px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.about-title {
  font-size: 2.5rem;
  margin-bottom: 2rem;
  text-align: center;
  color: #ffffff;
  position: relative;
  padding-bottom: 1rem;
  font-weight: 700;
  letter-spacing: 1px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  border-bottom: none;
  /* Removemos el borde inferior anterior */
}

.about-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 4px;
  background: linear-gradient(to right, #64ffda, #00bfa5);
  border-radius: 2px;
  box-shadow: 0 0 10px rgba(100, 255, 218, 0.6);
}

/* --- NUEVO LAYOUT RESPONSIVO --- */

.about-layout {
  /* Por defecto (móvil) los elementos se apilan */
  display: flex;
  flex-direction: column;
  gap: 40px;
  /* Espacio entre contenido principal y sidebar en móvil */
}

/* Media Query para pantallas anchas (a partir de 992px) */
@media (min-width: 992px) {
  .about-layout {
    /* Usamos Grid para un control preciso de las columnas */
    display: grid;
    grid-template-columns: 2fr 1fr;
    /* Columna principal 2/3, sidebar 1/3 */
    gap: 50px;
    /* Espacio entre columnas */
    align-items: flex-start;
    /* Alinea los elementos al inicio de su celda */
  }

  .about-main-content {
    /* La columna principal es la primera en el orden visual */
    order: 1;
  }

  .about-sidebar {
    /* La barra lateral es la segunda en el orden visual */
    order: 2;
  }
}

/* --- FIN DEL NUEVO LAYOUT --- */

.about-paragraph {
  margin-bottom: 22px;
  text-align: justify;
  color: #ccd6f6;
  /* Color más claro para mejor legibilidad */
  font-size: 1.05rem;
  line-height: 1.7;
}

.about-paragraph.final-paragraph {
  margin-top: 40px;
  /* Espacio extra para el párrafo final */
  text-align: center;
  font-style: italic;
  color: #8892b0;
}

.highlight {
  color: #0a192f;
  /* Texto oscuro para máximo contraste */
  background-color: #64ffda;
  /* Fondo sólido en color turquesa */
  padding: 3px 8px;
  border-radius: 4px;
  font-weight: 700;
  transition: all 0.3s ease;
  box-shadow: 0 0 6px rgba(100, 255, 218, 0.7);
  text-shadow: none;
  margin: 0 2px;
}

.highlight:hover {
  color: #0a192f;
  /* Mantener texto oscuro */
  background-color: #7bffde;
  /* Fondo ligeramente más claro al pasar el cursor */
  box-shadow: 0 0 10px rgba(100, 255, 218, 0.9);
  transform: translateY(-1px);
}

/* Sidebar styling */
.about-sidebar {
  background: #112240;
  padding: 25px;
  border-radius: 8px;
  position: sticky;
  /* Hace que la barra lateral se quede fija al hacer scroll */
  top: 100px;
  /* Distancia desde la parte superior (ajustar según altura del header) */
}

.about-sidebar h3 {
  color: #ffffff;
  text-align: center;
  margin-bottom: 20px;
  font-size: 1.5rem;
  border-bottom: 2px solid rgba(100, 255, 218, 0.3);
  padding-bottom: 10px;
}

.profile-section {
  display: flex;
  justify-content: center;
  margin-bottom: 25px;
}

.profile-image {
  width: 180px;
  height: 180px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #64ffda;
  /* Borde del color de acento */
  box-shadow: 0 0 20px rgba(100, 255, 218, 0.4);
  transition: transform 0.4s ease, box-shadow 0.4s ease;
}

.profile-image:hover {
  transform: scale(1.05) rotate(2deg);
  box-shadow: 0 0 25px rgba(100, 255, 218, 0.6);
}

/* Efecto de brillo alrededor de la imagen */
.profile-section::after {
  content: '';
  position: absolute;
  width: 220px;
  height: 220px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(100, 255, 218, 0.2) 0%, transparent 70%);
  z-index: -1;
  pointer-events: none;
}

.skills-list {
  list-style-type: none;
  padding: 0;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}

.skill-item {
  background-color: #0a192f;
  color: #64ffda;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 0.95rem;
  font-weight: 500;
  border: 1px solid rgba(100, 255, 218, 0.3);
  transition: all 0.3s ease;
}

.skill-item:hover {
  transform: translateY(-2px);
  background-color: rgba(100, 255, 218, 0.1);
}

/* Sección de experiencia */
.experience-section {
  margin-top: 40px;
}

.experience-section h3 {
  color: #ffffff;
  font-size: 1.6rem;
  margin-bottom: 25px;
  padding-bottom: 10px;
  border-bottom: 2px solid rgba(100, 255, 218, 0.3);
}

.timeline-item {
  margin-bottom: 30px;
  position: relative;
  padding-left: 30px;
  border-left: 2px solid rgba(100, 255, 218, 0.2);
}

.timeline-item:last-child {
  border-left: 2px solid transparent;
}

.timeline-item::before {
  content: '';
  position: absolute;
  left: -8px;
  top: 5px;
  /* Ajustado para alinear con el texto */
  width: 14px;
  height: 14px;
  background: #64ffda;
  border-radius: 50%;
  border: 2px solid #0a192f;
}

.timeline-date,
.timeline-role,
.timeline-company {
  margin-bottom: 4px;
}

.timeline-date {
  color: #64ffda;
  font-weight: 600;
}

.timeline-role {
  color: #ccd6f6;
  font-weight: 700;
  font-size: 1.15rem;
}

.timeline-company {
  color: #8892b0;
  font-style: italic;
}

/* Responsive */
@media (max-width: 991px) {
  .about-sidebar {
    position: static;
    /* Desactivar el sticky en móvil */
  }
}

@media (max-width: 480px) {
  .about-title {
    font-size: 2rem;
  }

  .about-paragraph {
    font-size: 0.95rem;
  }
}
</file>

<file path="src/App.js">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Header from './components/Header';
import Footer from './components/Footer';
import SidebarMenu from './components/SideBarMenu';
import Home from './components/Home';
import Blog from './components/Blog';
import About from './components/About';
import Login from './components/Login';
import BlogPost from './components/BlogPost';
import GamePage from './components/GamePage';
import ProtectedRoute from './components/ProtectedRoute';
import ErrorComponent from './components/ErrorComponent';
import TextEditor from './components/TextEditor';
import EditPost from './components/EditPost';
import Contact from './components/Contact';

import GamePlayer from './components/GamePlayer';
import 'bootstrap/dist/css/bootstrap.min.css';
import './App.css';

function App() {
  return (
    <Router>
      <div className="d-flex flex-column min-vh-100">
        <Header />
        <div className="d-flex flex-grow-1">
          <main className="flex-grow-1 main-content">
            <Routes>
              <Route path="/" element={<Home />} />
              <Route path="/blog" element={<Blog />} />
              <Route path="/about" element={<About />} />
              <Route path="/blog/:id" element={<BlogPost />} />
              <Route path="/login" element={<Login />} />
              <Route path="/games" element={<GamePage />} />
              <Route path="/games/:gameId" element={<GamePlayer />} />
              <Route path="/error" element={<ErrorComponent />} />
              <Route path="/contact" element={<Contact />} />
              <Route path="/edit" element={
                <ProtectedRoute>
                  <TextEditor />
                </ProtectedRoute>
              } />
              <Route path="/edit-post/:id" element={
                <ProtectedRoute>
                  <EditPost />
                </ProtectedRoute>
              } />
              {/* Aquí puedes añadir rutas para tus juegos individuales */}
            </Routes>
          </main>
          {/*  <SidebarMenu /> */}
        </div>
        <Footer />
      </div>
    </Router>
  );
}

export default App;
</file>

<file path="src/components/juegos/ThreeJSCSS3DSprites.js">
import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

const ThreeJSCSS3DSprites = () => {
  const mountRef = useRef(null);
  const rendererRef = useRef(null);
  const sceneRef = useRef(null);
  const frameIdRef = useRef(null);
  const controlsRef = useRef(null);
  const textureRef = useRef(null);
  const emissiveTextureRef = useRef(null);
  const geoRef = useRef(null);
  const matRef = useRef(null);

  useEffect(() => {
    if (!mountRef.current) return;

    let width = mountRef.current.clientWidth;
    let height = mountRef.current.clientHeight;

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      premultipliedAlpha: false
    });
    renderer.setClearColor(0x000000, 0); // Set clear color to transparent
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    const scene = new THREE.Scene();
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 2.5;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI / 2;
    controls.enableZoom = false;
    controls.enabled = false;
    controlsRef.current = controls;

    // Texture: Restore size and fixed font
    const canvasSize = 256;

    // Base texture
    const textCanvas = document.createElement('canvas');
    textCanvas.width = canvasSize;
    textCanvas.height = canvasSize;
    const ctx = textCanvas.getContext('2d');
    ctx.fillStyle = '#0A192F';
    ctx.fillRect(0, 0, canvasSize, canvasSize);
    ctx.font = 'bold 48px Arial';
    ctx.fillStyle = '#64FFDA';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Dante', canvasSize / 2, canvasSize / 2);
    const texture = new THREE.CanvasTexture(textCanvas);
    texture.needsUpdate = true;
    textureRef.current = texture;

    // Emissive texture
    const emissiveCanvas = document.createElement('canvas');
    emissiveCanvas.width = canvasSize;
    emissiveCanvas.height = canvasSize;
    const emissiveCtx = emissiveCanvas.getContext('2d');
    emissiveCtx.fillStyle = '#000000';
    emissiveCtx.fillRect(0, 0, canvasSize, canvasSize);
    emissiveCtx.font = 'bold 48px Arial';
    emissiveCtx.fillStyle = '#FFFFFF';
    emissiveCtx.textAlign = 'center';
    emissiveCtx.textBaseline = 'middle';
    emissiveCtx.fillText('Dante', canvasSize / 2, canvasSize / 2);
    const emissiveTexture = new THREE.CanvasTexture(emissiveCanvas);
    emissiveTexture.needsUpdate = true;
    emissiveTextureRef.current = emissiveTexture;

    // Geometría más detallada
    const geo = new THREE.IcosahedronGeometry(1.0, 4); // Aumentado de 3 a 4 para más detalle
    geoRef.current = geo;

    const mat = new THREE.MeshPhongMaterial({
      map: texture,
      emissive: new THREE.Color(0x64ffda), // Verde azulado para el brillo
      emissiveMap: emissiveTexture,
      emissiveIntensity: 0.7, // Aumentado de 0.6 a 0.7 para más brillo
      shininess: 80, // Aumentado de 15 a 80 para reflejos más nítidos
      specular: new THREE.Color(0xeeeeee), // Color del reflejo (gris claro)
      flatShading: false,
      transparent: false,
      opacity: 1.0
    });
    matRef.current = mat;

    const mesh = new THREE.Mesh(geo, mat);
    scene.add(mesh);

    // --- ILUMINACIÓN MEJORADA ---

    // Luz Hemisférica (color cielo, color suelo, intensidad)
    const hemisphereLight = new THREE.HemisphereLight(0xadc4ff, 0x4a4d4e, 0.8); // Tonos azulados/grisáceos
    scene.add(hemisphereLight);

    // Luz Direccional Principal (más intensa)
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Aumentada intensidad
    directionalLight.position.set(5, 5, 5); // Posición ajustada
    scene.add(directionalLight);

    // Luz Direccional Secundaria (de relleno o contra, color sutil)
    const directionalLight2 = new THREE.DirectionalLight(0x88aaff, 0.3); // Luz azulada suave
    directionalLight2.position.set(-5, 3, -5); // Desde dirección opuesta/lateral
    scene.add(directionalLight2);

    // --- FIN ILUMINACIÓN ---

    let lastTime = 0;
    const rotationSpeed = 0.05;

    let isVisible = true;
    const handleVisibilityChange = () => {
      isVisible = !document.hidden;
      if (!isVisible && frameIdRef.current) {
        cancelAnimationFrame(frameIdRef.current);
        frameIdRef.current = null;
      } else if (isVisible && !frameIdRef.current) {
        lastTime = performance.now();
        animate(lastTime);
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange);

    function animate(time) {
      frameIdRef.current = requestAnimationFrame(animate);

      if (!isVisible) return;

      const deltaTime = (time - lastTime) * 0.001;
      lastTime = time;

      if (sceneRef.current && rendererRef.current && controlsRef.current) {
        mesh.rotation.y += rotationSpeed * deltaTime;
        controlsRef.current.update();
        rendererRef.current.render(sceneRef.current, camera);
      }
    }
    animate(0);

    const handleResize = () => {
      if (mountRef.current && rendererRef.current && camera) {
        width = mountRef.current.clientWidth;
        height = mountRef.current.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        rendererRef.current.setSize(width, height);
      }
    };

    const handleMouseEnter = () => {
      if (controlsRef.current) {
        controlsRef.current.enabled = true;
      }
    };

    const handleMouseLeave = () => {
      if (controlsRef.current) {
        controlsRef.current.enabled = false;
      }
    };

    window.addEventListener('resize', handleResize);
    mountRef.current.addEventListener('mouseenter', handleMouseEnter);
    mountRef.current.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (mountRef.current) {
        mountRef.current.removeEventListener('mouseenter', handleMouseEnter);
        mountRef.current.removeEventListener('mouseleave', handleMouseLeave);
      }
      if (frameIdRef.current) {
        cancelAnimationFrame(frameIdRef.current);
      }
      if (mountRef.current && rendererRef.current) {
        mountRef.current.removeChild(rendererRef.current.domElement);
      }
      if (rendererRef.current) {
        rendererRef.current.dispose();
      }
      if (controlsRef.current) {
        controlsRef.current.dispose();
      }
      if (textureRef.current) textureRef.current.dispose();
      if (emissiveTextureRef.current) emissiveTextureRef.current.dispose();
      if (geoRef.current) geoRef.current.dispose();
      if (matRef.current) matRef.current.dispose();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      [rendererRef, sceneRef, controlsRef, textureRef,
        emissiveTextureRef, geoRef, matRef, frameIdRef].forEach(ref => {
          ref.current = null;
        });
    };
  }, []);

  return (
    <div
      ref={mountRef}
      style={{
        width: '100%',
        height: '300px',
        marginTop: '2rem',
        cursor: 'grab',
        background: 'transparent'
      }}
    />
  );
};

export default ThreeJSCSS3DSprites;
</file>

<file path="src/css/home.css">
/* Base styles */
html {
  scroll-behavior: smooth;
}

.home-container {
  width: 100%;
  background: linear-gradient(135deg, #0a192f, #112240, #1a365d);
  color: #e6f1ff;
  min-height: 100vh;
  overflow-x: hidden;
}

/* Hero Section */
.hero {
  min-height: 100vh;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 5rem 1rem 6rem 1rem;
  width: 100%;
  margin-bottom: 4rem;
}

.hero-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle at center, rgba(10, 25, 47, 0.5) 0%, rgba(10, 25, 47, 0.8) 100%);
}

.hero-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto 5rem auto;
  padding: 0 2rem;
  gap: 3rem;
  z-index: 2;
}

.hero-text {
  flex: 1 1 55%;
  max-width: 650px;
  text-align: left;
}

.hero-visual {
  flex: 1 1 45%;
  max-width: 500px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.hero-illustration {
  display: block;
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  box-shadow: 0 10px 30px -15px rgba(2, 12, 27, 0.7);
}

/* Three.js Section Wrapper */
.threejs-section-wrapper {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
  padding: 0 1rem;
}

.hero-game-container {
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 2rem;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2;
}

.greeting {
  display: block;
  font-size: 1.5rem;
  color: #64ffda;
  margin-bottom: 1rem;
}

.name {
  display: block;
  font-size: clamp(40px, 8vw, 70px);
  font-weight: 800;
  background: linear-gradient(90deg, #64ffda, #00bcd4);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  margin: 0.5rem 0;
  line-height: 1.1;
}

.subtitle {
  font-size: 1.5rem;
  color: #8892b0;
  margin: 1rem 0;
  opacity: 0.8;
  animation: fadeIn 2s ease-out;
}

.role-tags {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  margin: 1.5rem 0;
}

.role-tags span {
  padding: 0.5rem 1rem;
  background: rgba(100, 255, 218, 0.1);
  border: 1px solid #64ffda;
  border-radius: 4px;
  color: #64ffda;
  font-size: 0.9rem;
}

.cta-buttons {
  margin-top: 2rem;
  display: flex;
  gap: 1.5rem;
}

.cta-button {
  padding: 1rem 2rem;
  border-radius: 4px;
  text-decoration: none;
  font-weight: 600;
  transition: all 0.3s ease;
}

.cta-button.primary {
  background: #64ffda;
  color: #0a192f;
}

.cta-button.secondary {
  border: 1px solid #64ffda;
  color: #64ffda;
}

.cta-button:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.scroll-indicator {
  position: absolute;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  opacity: 0.7;
  color: #64ffda;
  z-index: 2;
}

.mouse {
  width: 30px;
  height: 50px;
  border: 2px solid #64ffda;
  border-radius: 15px;
  position: relative;
}

.mouse::before {
  content: '';
  position: absolute;
  width: 6px;
  height: 6px;
  background: #64ffda;
  left: 50%;
  top: 8px;
  transform: translateX(-50%);
  border-radius: 50%;
  animation: scroll 2s infinite;
}

/* About Section */
.about-section {
  padding: 100px 1rem;
  width: 100%;
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(5px);
}

.about-content {
  width: 90%;
  max-width: 1400px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 3fr 2fr;
  gap: 40px;
  align-items: start;
}

.about-text {
  color: #8892b0;
  line-height: 1.8;
}

.about-text p {
  margin-bottom: 1.5rem;
}

.skills-container {
  background: rgba(100, 255, 218, 0.05);
  padding: 2rem;
  border-radius: 8px;
  border: 1px solid rgba(100, 255, 218, 0.1);
}

.skills-container h3 {
  color: #64ffda;
  margin-bottom: 1rem;
}

.technologies {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.tech-item {
  background: rgba(100, 255, 218, 0.1);
  color: #64ffda;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.tech-item:hover {
  background: rgba(100, 255, 218, 0.2);
  transform: translateY(-3px);
}

/* Latest Post Section */
.latest-post-section {
  padding: 100px 1rem;
  width: 100%;
  background: rgba(10, 25, 47, 0.5);
}

.latest-post-section .section-title {
  width: 90%;
  max-width: 1400px;
  margin: 0 auto 2rem auto;
}

.latest-post-card {
  width: 90%;
  max-width: 1400px;
  margin: 0 auto;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 15px;
  overflow: hidden;
  display: flex;
  transition: transform 0.3s ease;
  border: 1px solid rgba(100, 255, 218, 0.1);
}

.latest-post-image {
  width: 300px;
  height: 250px;
  object-fit: cover;
}

.post-content {
  padding: 2rem;
  flex: 1;
}

.post-content h3 {
  color: #e6f1ff;
  margin-bottom: 1rem;
  font-size: 1.5rem;
}

.latest-post-excerpt {
  color: #8892b0;
  margin-bottom: 1.5rem;
  line-height: 1.6;
}

.read-more-link {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  background: #64ffda;
  color: #0a192f;
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.3s ease;
  font-weight: 600;
}

.read-more-link:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

/* Projects Section */
.projects-section {
  padding: 100px 1rem;
  width: 100%;
  background: rgba(255, 255, 255, 0.02);
}

.projects-section .section-title {
  width: 90%;
  max-width: 1400px;
  margin: 0 auto 2rem auto;
}

.projects-grid {
  width: 90%;
  max-width: 1400px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 30px;
  margin-top: 3rem;
}

.project-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  padding: 2rem;
  transition: all 0.3s ease;
  border: 1px solid rgba(100, 255, 218, 0.1);
  height: 100%;
  display: flex;
  flex-direction: column;
}

.project-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  border-color: #64ffda;
}

.project-card h3 {
  color: #e6f1ff;
  margin-bottom: 1rem;
  font-size: 1.3rem;
}

.project-card p {
  color: #8892b0;
  margin-bottom: 1.5rem;
  line-height: 1.6;
  flex-grow: 1;
}

.project-link {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  background: transparent;
  color: #64ffda;
  text-decoration: none;
  border-radius: 4px;
  border: 1px solid #64ffda;
  transition: all 0.3s ease;
  text-align: center;
}

.project-link:hover {
  background: rgba(100, 255, 218, 0.1);
  transform: translateY(-2px);
}

/* Footer */
.footer {
  width: 100%;
  background: rgba(10, 25, 47, 0.8);
  padding: 40px 0;
  text-align: center;
}

/* Section Titles */
.section-title {
  font-size: 2.5rem;
  margin-bottom: 2rem;
  text-align: center;
  color: #e6f1ff;
  position: relative;
  padding-bottom: 1rem;
}

.section-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 4px;
  background: #64ffda;
  border-radius: 2px;
}

/* Social Links */
.social-links {
  display: flex;
  justify-content: center;
  gap: 40px;
  padding: 20px 0;
}

.social-links a {
  color: #64ffda;
  font-size: 3rem;
  transition: all 0.3s ease;
  opacity: 0.9;
}

.social-links a:hover {
  color: #fff;
  transform: translateY(-3px);
  opacity: 1;
}

/* Loading State */
.loading {
  text-align: center;
  padding: 2rem;
  color: #8892b0;
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scroll {
  0% {
    transform: translate(-50%, 0);
    opacity: 1;
  }

  100% {
    transform: translate(-50%, 20px);
    opacity: 0;
  }
}

/* Responsive Design */
@media (max-width: 1024px) {
  .hero-content {
    gap: 2rem;
  }

  .name {
    font-size: 3.5rem;
  }
}

@media (max-width: 960px) {
  .hero {
    padding-bottom: 5rem;
    margin-bottom: 3rem;
  }

  .hero-content {
    flex-direction: column;
    text-align: center;
    gap: 2rem;
    margin-bottom: 3rem;
  }

  .hero-text {
    order: 1;
    max-width: 600px;
    text-align: center;
    padding-right: 0;
  }

  .hero-visual {
    order: 0;
    width: 80%;
    max-width: 400px;
    margin-bottom: 1.5rem;
  }

  .hero-illustration {
    /* Puedes añadir aquí estilos específicos para móvil si es necesario */
  }

  .hero-game-container {
    margin-top: 0;
    max-width: 95%;
  }

  .role-tags {
    justify-content: center;
  }

  .cta-buttons {
    justify-content: center;
  }

  #about,
  #latest-post,
  #projects {
    padding: 80px 1rem;
  }
}

@media (max-width: 768px) {
  .hero {
    padding: 3rem 1rem 4rem 1rem;
    margin-bottom: 2rem;
  }

  .hero-content {
    margin-bottom: 2rem;
  }

  .hero-visual {
    min-height: 200px;
    max-width: 300px;
  }

  .hero-game-container {
    padding: 0 0.5rem;
  }

  #about,
  #latest-post,
  #projects {
    padding: 60px 1rem;
  }

  .name {
    font-size: 2.5rem;
  }

  .subtitle {
    font-size: 1.2rem;
  }

  .about-content {
    grid-template-columns: 1fr;
    padding: 0 20px;
  }

  .latest-post-card {
    flex-direction: column;
  }

  .latest-post-image {
    width: 100%;
    height: 200px;
  }

  .scroll-indicator {
    display: none;
  }

  .social-links {
    gap: 30px;
  }

  .social-links a {
    font-size: 2.5rem;
  }
}

@media (max-width: 480px) {
  .greeting {
    font-size: 1.2rem;
  }

  .name {
    font-size: 2rem;
  }

  .subtitle {
    font-size: 1.1rem;
  }

  .cta-buttons {
    flex-direction: column;
  }

  .cta-button {
    width: 100%;
    text-align: center;
  }

  .social-links a {
    font-size: 2rem;
  }
}
</file>

<file path="src/components/About.js">
import React from 'react';
import '../css/about.css';
import profileImage from '../images/yo.png';

function About() {
  return (
    <div className="about-container">
      <h2 className="about-title">About Me</h2>

      {/* Nuevo contenedor para el layout de dos columnas */}
      <div className="about-layout">
        {/* Columna principal (izquierda en escritorio) */}
        <div className="about-main-content">
          <p className="about-paragraph">
            Hello! I'm a <span className="highlight">software engineer</span> with a degree in Computer Engineering from the University of Alicante, where I graduated in 2016. Since then, I have been continuously developing my skills and working in various roles within the tech industry.
          </p>

          <p className="about-paragraph">
            Currently, I'm working as a <span className="highlight">Backend Developer</span> at <span className="highlight">Adstella.ai</span>, where I utilize Python and PostgreSQL to build robust backend solutions. Previously, I split my time between developing personal projects and taking on freelance work for various clients, providing technical solutions ranging from web applications to automation systems.
          </p>

          <p className="about-paragraph">
            I have a passion for creating automation solutions and data-driven applications using <span className="highlight">Python</span>. These projects have allowed me to explore various problem-solving techniques and implement efficient systems for complex tasks.
          </p>

          <p className="about-paragraph">
            Since the emergence of AI-powered development tools, I've been actively exploring and utilizing various code generation and assistance technologies. I've gained experience with advanced language models and AI coding assistants, integrating these cutting-edge technologies into my development workflow to enhance productivity and explore innovative solutions.
          </p>

          {/* Timeline de Experiencia */}
          <div className="experience-section">
            <h3>Professional Journey</h3>
            <div className="timeline-item">
              <div className="timeline-date">February 2025 - Present</div>
              <div className="timeline-role">Backend Developer</div>
              <div className="timeline-company">Adstella.ai</div>
              <p>Working with Python and PostgreSQL to develop robust backend solutions, focusing on scalable API development and database optimization.</p>
            </div>
            <div className="timeline-item">
              <div className="timeline-date">August 2024 - February 2025</div>
              <div className="timeline-role">Independent Developer & Freelancer</div>
              <div className="timeline-company">Personal Projects & Client Work</div>
              <p>Developed multiple personal projects showcased on this website while taking on freelance assignments for various clients. Freelance work included web application development, automation solutions, and technical consulting services.</p>
            </div>
            <div className="timeline-item">
              <div className="timeline-date">2020 - August 2024</div>
              <div className="timeline-role">Programming & Mobile App Development Instructor</div>
              <div className="timeline-company">Vocational Training Institute</div>
              <p>Taught and inspired future developers while keeping up to date with the latest industry trends and technologies.</p>
            </div>
            <div className="timeline-item">
              <div className="timeline-date">2016 - 2020</div>
              <div className="timeline-role">Java Developer</div>
              <div className="timeline-company">NTT Data</div>
              <p>Developed and maintained web platforms for a major bank, gaining extensive experience in large-scale web applications and backend development.</p>
            </div>
          </div>
        </div>

        {/* Barra lateral (derecha en escritorio) */}
        <div className="about-sidebar">
          <div className="profile-section">
            <img src={profileImage} alt="Dante Collazzi" className="profile-image" />
          </div>
          <h3>Key Skills</h3>
          <ul className="skills-list">
            <li className="skill-item">Python</li>
            <li className="skill-item">PostgreSQL</li>
            <li className="skill-item">Java</li>
            <li className="skill-item">JavaScript</li>
            <li className="skill-item">React</li>
            <li className="skill-item">Flutter</li>
            <li className="skill-item">AI Integration</li>
          </ul>
        </div>
      </div>

      {/* Párrafo final (opcional, fuera del layout de columnas si quieres que ocupe todo el ancho) */}
      <p className="about-paragraph final-paragraph">
        I'm always eager to learn new skills and take on challenging projects that push the boundaries of what I can do, especially at the intersection of traditional software development and emerging AI technologies.
      </p>
    </div>
  );
}

export default About;
</file>

<file path="src/components/GamePage.js">
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import '../css/GamePage.css';
import snakeImage from '../images/snake-game.png';
import snake3dImage from '../images/snake-3d.png';
import pongImage from '../images/pong-game.png';
import footballImage from '../images/mamvsreptiles.webp';
import handInvadersImage from '../images/hand-invaders-preview.png';
import supermarcosImage from '../images/supermarcos.png';
import guessCountryImage from '../images/guess-country.png';

const GamesPage = () => {
    const navigate = useNavigate();
    const [selectedGame, setSelectedGame] = useState(null);
    const [roomStates, setRoomStates] = useState({
        room1: {
            playerCount: 0,
            players: [],
            gameInProgress: false
        },
        room2: {
            playerCount: 0,
            players: [],
            gameInProgress: false
        }
    });

    // Generic function to fetch room status
    const fetchRoomStatus = async (roomId) => {
        try {
            const response = await fetch(`https://football-online-3d.dantecollazzi.com/${roomId}/status`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            if (response.ok) {
                return await response.json();
            } else {
                console.warn(`${roomId} status response not OK:`, response.status);
                return null;
            }
        } catch (error) {
            console.log(`Error fetching ${roomId} status:`, error.message);
            return null;
        }
    };

    useEffect(() => {
        const availableRooms = ['room1', 'room2']; // Cambiado a room1/room2 como en la API

        // Función para actualizar todos los estados de las salas vía API REST
        const updateAllRoomsStatus = async () => {
            let newRoomStates = {};
            for (const roomId of availableRooms) {
                const data = await fetchRoomStatus(roomId);
                newRoomStates[roomId] = {
                    playerCount: data?.playerCount || 0,
                    players: data?.players || [],
                    gameInProgress: data?.gameInProgress || false,
                    // Mantenemos un estado por defecto si la petición falla
                    ...(data === null && { playerCount: 0, players: [], gameInProgress: false }) // Estado por defecto si falla
                };
            }
            setRoomStates(prev => ({ ...prev, ...newRoomStates })); // Actualizar estado
        };

        // Actualización inicial
        updateAllRoomsStatus();

        // Configurar actualizaciones periódicas
        const statusInterval = setInterval(updateAllRoomsStatus, 10000); // Cada 10 segundos

        // Función de limpieza
        return () => {
            clearInterval(statusInterval);
            // Ya no hay sockets que desconectar aquí
        };
    }, []); // No need for fetchRoomStatus as dependency since it's defined in the component

    // Modifica handleJoinRoom para abrir en una nueva pestaña
    const handleJoinRoom = (roomIdNumber) => {
        const gameUrl = `https://football-online-3d.dantecollazzi.com?room=${roomIdNumber}`;
        // Abre la URL directamente en una nueva pestaña
        window.open(gameUrl, '_blank', 'noopener,noreferrer'); // Añadir rel por seguridad
    };

    const games = {
        singlePlayer: [
            {
                id: 'snake',
                name: 'Snake Classic',
                description: 'The classic Snake game. Guide the snake, collect food, and try not to hit the walls!',
                image: snakeImage
            },
            {
                id: 'SnakeGame3D',
                name: 'Snake 3D',
                description: 'A modern 3D twist on the classic Snake game. Experience snake-gaming in a whole new dimension!',
                image: snake3dImage
            },
            {
                id: 'pong',
                name: 'Pong',
                description: 'Classic arcade game. Challenge yourself against the AI in this timeless tennis-style game.',
                image: pongImage
            },
            {
                id: 'hand-invaders',
                name: 'Hand Invaders',
                description: 'Defend against invaders using your hand gestures!',
                image: handInvadersImage
            },
            {
                id: 'supermarcos',
                name: 'SuperMarcos',
                description: 'An awesome new adventure game starring Marcos!',
                image: supermarcosImage
            },
            {
                id: 'guess-the-country',
                name: 'Guess The Country',
                description: 'Test your geography knowledge! Click on the map to guess the 15 most populous countries.',
                image: guessCountryImage
            }
        ],
        multiplayer: [
            {
                id: 'mammals-vs-reptiles',
                name: 'Mammals vs Reptiles',
                description: 'An exciting 3D football game where mammals compete against reptiles in epic matches!',
                image: footballImage,
                rooms: [
                    {
                        id: 'room1', // <--- USA 'room1'
                        name: 'Room 1',
                        description: 'Main game room',
                        roomIdNumber: 1 // Añadir número para la navegación
                    },
                    {
                        id: 'room2', // <--- USA 'room2'
                        name: 'Room 2',
                        description: 'Secondary game room',
                        roomIdNumber: 2 // Añadir número para la navegación
                    }
                ]
            }
        ]
    };

    const SinglePlayerGameCard = ({ game }) => (
        <Link to={`/games/${game.id}`} className="game-card">
            <div className="game-card-image-container">
                <img
                    src={game.image}
                    alt={game.name}
                    className="game-card-image"
                    onError={(e) => {
                        e.target.src = 'https://via.placeholder.com/300x180?text=Game+Preview';
                    }}
                />
            </div>
            <div className="game-card-content">
                <h3>{game.name}</h3>
                <p>{game.description}</p>
            </div>
        </Link>
    );

    const MultiplayerGameCard = ({ game }) => (
        <div className="game-card" onClick={() => setSelectedGame(game)}>
            <div className="game-card-image-container">
                <img
                    src={game.image}
                    alt={game.name}
                    className="game-card-image"
                    onError={(e) => {
                        e.target.src = 'https://via.placeholder.com/300x180?text=Game+Preview';
                    }}
                />
            </div>
            <div className="game-card-content">
                <h3>{game.name}</h3>
                <p>{game.description}</p>
            </div>
        </div>
    );

    const RoomCard = ({ room }) => {
        const roomState = roomStates[room.id] || { playerCount: 0, players: [], gameInProgress: false }; // Estado por defecto

        return (
            <div key={room.id} className="room-card">
                <h3>{room.name}</h3>
                <p>{room.description}</p>

                <div className="room-status">
                    <div className="game-status">
                        <span className={`status-indicator ${roomState.gameInProgress ? 'in-progress' : 'waiting'}`}>
                            {roomState.gameInProgress ? 'Game in Progress' : 'Waiting for Players'}
                        </span>
                    </div>

                    <div className="players-info">
                        <span className="player-count">
                            {roomState.playerCount} {roomState.playerCount === 1 ? 'player' : 'players'} online
                        </span>

                        {roomState.players.length > 0 && (
                            <div className="players-list">
                                <div className="team">
                                    <h4>Mammals</h4>
                                    {roomState.players
                                        .filter(p => p.team === 'left')
                                        .map(player => (
                                            <span key={player.id} className="player-name mammals">
                                                {player.name}
                                            </span>
                                        ))
                                    }
                                </div>
                                <div className="team">
                                    <h4>Reptiles</h4>
                                    {roomState.players
                                        .filter(p => p.team === 'right')
                                        .map(player => (
                                            <span key={player.id} className="player-name reptiles">
                                                {player.name}
                                            </span>
                                        ))
                                    }
                                </div>
                            </div>
                        )}
                    </div>
                </div>

                <button
                    onClick={() => handleJoinRoom(room.roomIdNumber)} // Usa el número
                    className="join-button"
                >
                    Join Room
                </button>
            </div>
        );
    };

    if (selectedGame) {
        return (
            <div className="games-page">
                <h2>{selectedGame.name} - Available Rooms</h2>
                <button
                    onClick={() => setSelectedGame(null)}
                    className="back-button"
                >
                    Back to Games
                </button>
                <div className="rooms-grid">
                    {selectedGame.rooms.map(room => (
                        <RoomCard key={room.id} room={room} />
                    ))}
                </div>
            </div>
        );
    }

    return (
        <div className="games-page">
            <h1>Games Collection</h1>
            <section className="games-section">
                <h2>Single Player Games</h2>
                <div className="games-grid">
                    {games.singlePlayer.map((game) => (
                        <SinglePlayerGameCard key={game.id} game={game} />
                    ))}
                </div>
            </section>

            <section className="games-section">
                <h2>Multiplayer Games</h2>
                <div className="games-grid">
                    {games.multiplayer.map((game) => (
                        <MultiplayerGameCard key={game.id} game={game} />
                    ))}
                </div>
            </section>
        </div>
    );
};

export default GamesPage;
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local
.env.production
.env.development
.env

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# deployment
deploy.sh

# firebase config
/src/config/firebase-config.js
</file>

<file path="package.json">
{
  "name": "primerapaginaconreact",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@react-three/fiber": "^8.15.15",
    "@shadcn/ui": "^0.0.4",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@tinymce/tinymce-react": "^4.3.2",
    "@tweenjs/tween.js": "^25.0.0",
    "autoprefixer": "^10.4.17",
    "axios": "^1.8.4",
    "babylonjs": "^7.29.0",
    "babylonjs-loaders": "^7.29.0",
    "bootstrap": "^5.3.2",
    "d3": "^7.9.0",
    "dompurify": "^3.1.6",
    "firebase": "^10.14.1",
    "lucide-react": "^0.469.0",
    "phaser": "^3.70.0",
    "postcss": "^8.4.33",
    "prism-themes": "^1.9.0",
    "prismjs": "^1.29.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icon": "^1.0.0",
    "react-icons": "^5.3.0",
    "react-router-dom": "^6.21.3",
    "react-scripts": "^5.0.1",
    "socket.io-client": "^4.7.4",
    "styled-components": "^6.1.13",
    "tailwindcss": "^3.4.1",
    "three": "^0.160.1",
    "topojson-client": "^3.1.0",
    "xterm": "^5.3.0",
    "xterm-addon-fit": "^0.8.0",
    "xterm-addon-search": "^0.13.0",
    "xterm-addon-unicode11": "^0.6.0",
    "xterm-addon-web-links": "^0.9.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11"
  }
}
</file>

<file path="src/components/GameRegistry.js">
// GameRegistry.js
const gameRegistry = {
  'snake': {
    path: () => import('./juegos/SnakeGame'),
    name: 'snake',
    description: 'Classic Snake game.'
  },
  'SnakeGame3D': {
    path: () => import('./juegos/SnakeGame3D'),
    name: 'SnakeGame3D',
    description: 'Snake game in 3D.'
  },
  'pong': {
    path: () => import('./juegos/PongGame'),
    name: 'pong',
    description: 'Classic arcade game.'
  },
  cube: {
    path: () => import('./juegos/Cube'),
    name: 'cube',
    description: 'Puzzle game.'
  },
  modelViewer: {
    path: () => import('./juegos/ModelViewer'),
    name: 'modelViewer',
    description: 'ModelViewer.'
  },
  EnhancedCubes: {
    path: () => import('./juegos/EnhancedCubes'),
    name: 'EnhancedCubes',
    description: 'EnhancedCubes.'
  },
  ThreeJSCSS3DSprites: {
    path: () => import('./juegos/ThreeJSCSS3DSprites'),
    name: 'ThreeJSCSS3DSprites',
    description: 'ThreeJSCSS3DSprites.'
  },
  CarViewer: {
    path: () => import('./juegos/CarViewer'),
    name: 'CarViewer',
    description: 'CarViewer.'
  },
  Terminal: {
    path: () => import('./juegos/Terminal'),
    name: 'Terminal',
    description: 'Terminal.'
  },
  Runner3D: {
    path: () => import('./juegos/Runner3D'),
    name: 'Runner3D',
    description: 'Runner3D.'
  },
  "hand-invaders": {
    path: () => import('./juegos/HandInvadersGame'),
    name: 'Hand Invaders',
    description: 'Defend against invaders using your hand gestures!'
  },
  'supermarcos': {
    path: () => import('./juegos/SuperMarcos'),
    name: 'SuperMarcos',
    description: 'An awesome new adventure game starring Marcos!'
  },

  'guess-the-country': {
    path: () => import('./juegos/GuessTheCountry'),
    name: 'Guess The Country',
    description: 'Guess the 15 most populous countries on an interactive map.'
  }

  // Añade más juegos aquí
};

export default gameRegistry;
</file>

<file path="src/components/Home.js">
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import DOMPurify from 'dompurify';
import { FaGithub, FaLinkedin, FaTwitter } from 'react-icons/fa';
import '../css/home.css';
// Remove the ThreeJS import if you're not using it elsewhere
// import ThreeJSCSS3DSprites from './juegos/ThreeJSCSS3DSprites';
import ThreeJSCSS3DSprites from './juegos/ThreeJSCSS3DSprites'; // <--- Importa el componente 3D
import developerIllustration from '../images/developer-illustration.png'; // <-- Import the image

function Home() {
  const technologies = ['Java', 'Python', 'React', 'Node.js', 'SQL', 'Git', 'AI-assisted development', 'Flutter'];
  const [latestPost, setLatestPost] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  const apiUrl = process.env.REACT_APP_API_URL;

  useEffect(() => {
    setIsLoading(true);
    fetch(`${apiUrl}/api/posts?page=1&pageSize=1`)
      .then(response => response.json())
      .then(data => {
        if (data.posts && data.posts.length > 0) {
          setLatestPost(data.posts[0]);
        }
        setIsLoading(false);
      })
      .catch(error => {
        console.error('Error fetching latest blog post:', error);
        setIsLoading(false);
      });
  }, [apiUrl]);

  const createMarkup = (html) => {
    return { __html: DOMPurify.sanitize(html) };
  };

  return (
    <div className="home-container">
      <header className="hero">
        <div className="hero-overlay"></div>
        <div className="hero-content">
          <div className="hero-text">
            <h1 className="main-title">
              <span className="greeting">Hello, I'm</span>
              <span className="name">Dante Collazzi</span>
            </h1>
            <p className="subtitle">Let's build together</p>
            <div className="role-tags">
              <span>Software Developer</span>
              <span>Educator</span>
              <span>Tech Enthusiast</span>
            </div>
            <div className="cta-buttons">
              <a href="#projects" className="cta-button primary">View Projects</a>
              <Link to="/blog" className="cta-button secondary">Read Blog</Link>
            </div>
          </div>

          <div className="hero-visual">
            {/* Replace ThreeJS component with the image */}
            <img
              src={developerIllustration}
              alt="Developer coding at night"
              className="hero-illustration" // Add a class for styling
            />
          </div>
        </div>

        <div className="scroll-indicator">
          <div className="mouse"></div>
          <span>Scroll to explore</span>
        </div>
      </header>

      {/* === Coloca el componente Three.js aquí === */}
      <div className="threejs-section-wrapper"> {/* Opcional: para centrar o limitar ancho */}
        <ThreeJSCSS3DSprites />
      </div>
      {/* ========================================== */}

      <section id="about" className="about-section">
        <h2 className="section-title">About Me</h2>
        <div className="about-content">
          <div className="about-text">
            <p>
              Hello! I'm Dante, a passionate developer with years of experience in creating elegant solutions
              to complex problems. My journey in tech has been driven by curiosity and a desire to make a positive impact.
            </p>
            <p>
              With a strong foundation in Java and Python, I've honed my skills across various aspects of software development.
              From building robust backend systems to crafting intuitive user interfaces, I approach each project with
              enthusiasm and attention to detail.
            </p>
            <p>
              My experience includes a rewarding period as a programming instructor, which broadened my perspective
              and enhanced my ability to communicate complex concepts effectively.
            </p>
            <p>
              Recently, I've been exploring AI-assisted development tools, integrating them into my workflow
              to enhance productivity and push the boundaries of what's possible in software development.
            </p>
          </div>
          <div className="skills-container">
            <h3>Tech Stack</h3>
            <div className="technologies">
              {technologies.map((tech, index) => (
                <span key={index} className="tech-item">
                  {tech}
                </span>
              ))}
            </div>
          </div>
        </div>
      </section>

      <section id="latest-post" className="latest-post-section">
        <h2 className="section-title">Latest from the Blog</h2>
        {isLoading ? (
          <div className="loading">Loading latest post...</div>
        ) : latestPost ? (
          <div className="latest-post-card">
            {latestPost.imageUrl && (
              <img
                src={latestPost.imageUrl}
                alt={latestPost.title}
                className="latest-post-image"
              />
            )}
            <div className="post-content">
              <h3>{latestPost.title}</h3>
              <div
                className="latest-post-excerpt"
                dangerouslySetInnerHTML={createMarkup(latestPost.content.substring(0, 150) + '...')}
              />
              <Link to={`/blog/${latestPost.id}`} className="read-more-link">Read More</Link>
            </div>
          </div>
        ) : (
          <p>No posts available at the moment.</p>
        )}
      </section>

      <section id="projects" className="projects-section">
        <h2 className="section-title">Featured Projects</h2>
        <div className="projects-grid">
          <div className="project-card">
            <h3>3D Online Football Game</h3>
            <p>
              A multiplayer 3D football game built with Three.js and Socket.IO. Features real-time
              multiplayer gameplay, team selection system, and interactive 3D graphics. Players can
              join different rooms and compete in dynamic football matches.
            </p>
            <a
              href="https://github.com/PitiGo/frontend_futball_3d_online"
              className="project-link"
              target="_blank"
              rel="noopener noreferrer"
            >
              View on GitHub
            </a>
          </div>

          <div className="project-card">
            <h3>Personal Website</h3>
            <p>
              This website showcases my journey as a developer, featuring a blog and
              embedded games, built with React and modern web technologies.
            </p>
            <a
              href="https://github.com/PitiGo/petalo9.com-Frontend"
              className="project-link"
              target="_blank"
              rel="noopener noreferrer"
            >
              View on GitHub
            </a>
          </div>

          <div className="project-card">
            <h3>Easy Budget</h3>
            <p>
              A modern web application for personal budget management with real-time banking integration.
              Inspired by YNAB (You Need A Budget), it allows users to connect their bank accounts
              and effectively manage their budget through an intuitive interface.
            </p>
            <a
              href="https://github.com/PitiGo/Presupuesto_facil"
              className="project-link"
              target="_blank"
              rel="noopener noreferrer"
            >
              View on GitHub
            </a>
          </div>
        </div>
      </section>

      <footer className="footer">
        <div className="social-links">
          <a href="https://github.com/PitiGo" target="_blank" rel="noopener noreferrer">
            <FaGithub />
          </a>
          <a href="https://www.linkedin.com/in/dantecollazzi/" target="_blank" rel="noopener noreferrer">
            <FaLinkedin />
          </a>
          <a href="https://x.com/DAcerbus" target="_blank" rel="noopener noreferrer">
            <FaTwitter />
          </a>
        </div>
      </footer>
    </div>
  );
}

export default Home;
</file>

</files>
